<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/15/springBoot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/15/springBoot/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-15 22:00:49" itemprop="dateCreated datePublished" datetime="2021-04-15T22:00:49+08:00">2021-04-15</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/01/SSM%E6%A1%86%E6%9E%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/01/SSM%E6%A1%86%E6%9E%B6/" class="post-title-link" itemprop="url">SSM框架</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-01 11:26:32" itemprop="dateCreated datePublished" datetime="2020-12-01T11:26:32+08:00">2020-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 13:00:01" itemprop="dateModified" datetime="2021-05-27T13:00:01+08:00">2021-05-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="SSM框架-mybites框架"><a href="#SSM框架-mybites框架" class="headerlink" title="SSM框架-mybites框架"></a>SSM框架-mybites框架</h1><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ol>
<li><p>创建maven工程并且引入坐标</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11 <span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>创建实体类和dao的接口</p>
</li>
<li><p>创建Mybatis的主配置文件（SqlMapConfig.xml）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



</li>
</ol>
   <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/BlogMapper.xml&quot;</span>/&gt;</span><span class="comment">&lt;!--通过xml的方式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.example.BlogDao&quot;</span>/&gt;</span><span class="comment">&lt;!--通过注解的方式，class为注解的类--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ol start="4">
<li><p>创建映射配置文件（IUserDao.xml）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;org.mybatis.example.BlogMapper&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectBlog&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Blog&quot;</span>&gt;</span></span><br><span class="line">    select * from Blog where id = #&#123;id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><ol>
<li>创建映射配置文件时，文件的目录结构要和dao层的目录结构相同，方便mybatis的自动寻找。</li>
<li>映射配置文件的mapper标签namespace属性取值dao接口的权限定类名</li>
<li>映射配置文件的操作配置（select），id属性取值dao接口类的方法名</li>
</ol>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 配置文件</span></span><br><span class="line">InputStream in =Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line"><span class="comment">// 创建SqlSessionFactory 对象 并且得到session对象</span></span><br><span class="line">SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">SqlSession sqlSession = factory.openSession();</span><br><span class="line"><span class="comment">// 通过session对象获取到dao接口的动态代理对象</span></span><br><span class="line">IUser userimpl = sqlSession.getMapper(IUser.class);</span><br><span class="line"><span class="comment">// 使用动态代理类得到数据</span></span><br><span class="line">List&lt;user&gt; all = userimpl.getAll();</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">sqlSession.close();</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure>

<h4 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h4><ol>
<li>使用类加载器读取，他只能读取类路径下的配置文件。</li>
<li>使用ServletContext对象的getRealPath()方法读取配置文件。</li>
</ol>
<h4 id="mybatis使用代理dao的方式实现的增删改查方式"><a href="#mybatis使用代理dao的方式实现的增删改查方式" class="headerlink" title="mybatis使用代理dao的方式实现的增删改查方式"></a>mybatis使用代理dao的方式实现的增删改查方式</h4><ol>
<li><p>创建代理对象（可以使用dom4j的技术来解析xml文件）</p>
<p>连接数据库的信息（xml文件中）connection</p>
<p>mapper映射配置信息</p>
<p>通过mapper配置信息找到所对应的sql语句 和 封装的实体类限定名    prepareStatement</p>
</li>
</ol>
<ol start="2">
<li>使用代理对象调用增删改查方法</li>
</ol>
<p>——————————东软</p>
<p>dispatchServlet 是 springmvc的核心拦截器，拦截所有的请求</p>
<p>handlerMapping 相当于MAP  ， key 为 url ，value 为 Handler</p>
<ul>
<li>Handler   里面有类名，方法名，参数列表</li>
</ul>
<p>handlerMapping 将 Handler 返回给 dispatchServlet </p>
<p>dispatchServlet  将获取到的对象给 HandlerAdapter</p>
<p>HandlerAdapter 解析 Handler   里面的类名，方法名，参数列表 并进行<strong>调用</strong></p>
<p>HandlerAdapter 调用完的返回值给 dispatchServlet  </p>
<p>dispatchServlet  将返回值 给 视图解析器</p>
<p>视图解析器  通过返回值找到相应的页面进行转发。</p>
<h2 id="handlerMapping"><a href="#handlerMapping" class="headerlink" title="handlerMapping"></a>handlerMapping</h2><p><strong>注意</strong> ：需要配置handlerMapping的配置文件 namespace 或者（servlet名字-service）  WEB-INF目录下面</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.开启注解驱动</span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">2、包扫瞄（只有包里面加了@Controller注解的类才会被扫描到，方法上加上@RequestMapping注解）</span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;被扫描的包名&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">3、配置视图解析器</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;viewClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.springframework.web.servlet.view.JstlView&quot;</span>&gt;</span>		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/pages&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>向作用域里放入变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、使用HttpServletRequest</span></span><br><span class="line">HttpServletRequest.setAttribute(key,value)</span><br><span class="line"><span class="comment">// 2、使用ModalMap</span></span><br><span class="line">ModalMap.setAttribute(key,value)</span><br><span class="line"><span class="comment">//3、使用ModalAndView，需要先new一个对象 并且返回值改变为ModalAndView</span></span><br><span class="line">ModalAndView modalAndView = <span class="keyword">new</span> ModalAndView(<span class="string">&quot;abcd&quot;</span>) <span class="comment">// abcd 是js页面</span></span><br><span class="line">modalAndView.addObject(key,value)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用springmvc 重定向 return “redirect:xxx”</p>
<h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><p>使用了前后端分离，就不能进行转发和重定向了，应该向前台发送json或者xml来传送字符流。</p>
<p>可以使用fastJson来进行对象与json之间的转换。</p>
<p>使用 JSONObject.toJSONString()</p>
<p>如果想直接返回json数组，而不想转发或者重定向到jsp页面上。可以使用@ResponseBody注解或者使用response.getWriter().write(json字符串)</p>
<p>前后端分离会产生跨域请求问题：解决方法（使用filter）filter所在包org.catalina.filters.CorsFilter  </p>
<h3 id="VUEJS"><a href="#VUEJS" class="headerlink" title="VUEJS"></a>VUEJS</h3><p>vuejs是分区域进行控制的，可以绑定数据</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Vue =   <span class="keyword">new</span> VUE(&#123;“el”:<span class="string">&quot;#app&quot;</span>,<span class="string">&quot;data&quot;</span>:&#123;<span class="string">&quot;abcd&quot;</span>:<span class="string">&quot;123456&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>数据使用 </p>
<p>使用for循环或if 要在标签里面写,与jstl不同，jstl是进行包裹。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;tr v-<span class="keyword">for</span>=<span class="string">&quot;student in list&quot;</span>&gt;</span><br><span class="line">&lt;td&gt;&#123;&#123;student.name&#125;&#125;&lt;/td&gt;    </span><br><span class="line">&lt;/tr&gt;</span><br></pre></td></tr></table></figure>

<p>使用v-model进行双向绑定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; @click 代表使用vue里面的方法,如果使用vue作用域中的内容，则不再需要&#123;&#123;&#125;&#125; eg:@click&#x3D;del(student.id)</span><br><span class="line">var Vue &#x3D;   new VUE(&#123;</span><br><span class="line">“el”:&quot;#app&quot;,</span><br><span class="line">&quot;data&quot;:&#123;</span><br><span class="line">&quot;abcd&quot;:&quot;123456&quot;,</span><br><span class="line">&quot;student&quot;:&#123;</span><br><span class="line">	&quot;name&quot;:&quot;&quot;,</span><br><span class="line">	&quot;age&quot;:&quot;&quot;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;methods&quot;:&#123;</span><br><span class="line">  &quot;submit&quot;:function()&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<p>数据库</p>
<p>模糊查询 添加条件 用concat函数进行字符串拼接</p>
<p>IOC控制反转   使用setting注入和构造注入，建造xml文件，每一个对象是一个bean （要有id 和 class）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;i3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.neuedu.test.I3&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- setter注入，条用set方法为私有属性赋值 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注意name不是属性的名字，是setter方法去掉set首字母大写 与el表达式相同--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;abc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 构造方法给私有属性赋值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;abc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mainBoard&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.neuedu.test.MainBoard&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 如果属性是一个对象的话，value改成ref --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cpu&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;i3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">     </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用配置文件实现工厂模式</p>
<p>导包  spring-context (applicationContext.xml 是写bean的xml，名字随便取)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:applicationContext.xml&quot;</span>)</span><br><span class="line">MainBoard mainBoard = (MainBoard)context.getBean(<span class="string">&#x27;mainBoard&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>使用spring的IOC（控制反转）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.neuedu.test&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>类上添加@Component @Repository @Service @Controller 这四种注解的其中一种都能被扫描进去</p>
<p>依赖的属性要写上@Autowired @Resource 注解</p>
<p>main方法无法提前解析配置文件，所以只能使用JUNIT进行测试。还要导入spring的测试包。spring testContex framework, 而且需要在测试类上加上@RunWith(SpringJUnit4ClassRunner.class) 为了告诉启动时加载xml配置文件。@contextConfiguration(locations=”classpath:applicationContext.xml”) 为了告诉配置文件在哪里。</p>
<h3 id="监听器（可以实现服务器启动解析配置文件）需要在web-xml文件中配置listener节点"><a href="#监听器（可以实现服务器启动解析配置文件）需要在web-xml文件中配置listener节点" class="headerlink" title="监听器（可以实现服务器启动解析配置文件）需要在web.xml文件中配置listener节点"></a>监听器（可以实现服务器启动解析配置文件）需要在web.xml文件中配置listener节点</h3><p>创建过程 实现 listener接口</p>
<p>​    web.xml中配置listener（org.springframework.web.context.ContextLoaderListener）</p>
<p>​    还要配置一个参数告诉监听器配置文件是哪一个。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicatinContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>stringUtils类可是判断是否字符串为空，需要导包 org.apache.commons.lang3.StringUtils </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/01/YML%20%E8%AF%AD%E8%A8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/01/YML%20%E8%AF%AD%E8%A8%80/" class="post-title-link" itemprop="url">YML语言</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-01 11:26:32" itemprop="dateCreated datePublished" datetime="2020-12-01T11:26:32+08:00">2020-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-25 20:13:48" itemprop="dateModified" datetime="2021-03-25T20:13:48+08:00">2021-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>YML 语言</p>
<p>​    key: value格式（value前必须有空格，可以有多个，不能用tab键替代）</p>
<p>​    大小写敏感</p>
<p>​    字符串默认不需要使用引号，单引号和双引号的区别是单引号不支持转移字符</p>
<p>​    注释方式：#</p>
<p>YML支持的三种数据类型</p>
<p>​    字面量：直接量，单个不能被拆分的值（数字、字符串、布尔）</p>
<p>​    对象：键值对形式存在</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对象的写法</span></span><br><span class="line"><span class="attr">friend:</span></span><br><span class="line">	<span class="attr">name:</span> <span class="string">lisi</span></span><br><span class="line">	<span class="attr">sex:</span> <span class="string">女</span></span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="attr">friend:</span> &#123;<span class="attr">name:</span> <span class="string">lisi</span>,<span class="attr">sex:</span> <span class="string">女</span>&#125;</span><br></pre></td></tr></table></figure>

<p>​    数组：字面量/对象的组合</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#数组的写法</span></span><br><span class="line"><span class="attr">pets:</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">小狗</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">小猫</span></span><br><span class="line">	<span class="bullet">-</span> <span class="string">小猪</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="attr">pets:</span> [<span class="string">小狗，小猫，小猪</span>]</span><br></pre></td></tr></table></figure>

<p>Value注入：${字面量}、${配置文件中取值}、#{spEL表达式}</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;Person&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;lastName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;字面量/$&#123;key&#125;从环境变量、配置文件中获取值/         #&#123;SpEL&#125;&quot;</span>&gt;</span>	<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/01/Mobx-React%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%BA%93%EF%BC%88%E5%85%A5%E9%97%A8%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/01/Mobx-React%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%BA%93%EF%BC%88%E5%85%A5%E9%97%A8%EF%BC%89/" class="post-title-link" itemprop="url">Mobx:React状态管理库（入门）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-01 11:26:32" itemprop="dateCreated datePublished" datetime="2020-12-01T11:26:32+08:00">2020-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-25 18:50:09" itemprop="dateModified" datetime="2021-03-25T18:50:09+08:00">2021-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="React、mobx之间的关系"><a href="#React、mobx之间的关系" class="headerlink" title="React、mobx之间的关系"></a>React、mobx之间的关系</h2><p>React和mobx之间相辅相成，react将应用状态转化为可渲染的组件树进行视图的更新，mobx用来存储和更新应用状态。</p>
<h2 id="mobx的基本使用"><a href="#mobx的基本使用" class="headerlink" title="mobx的基本使用"></a>mobx的基本使用</h2><p>mobx的流程</p>
<p><img src="img%5C1521798430-5a42021889036_articlex.png" alt="1521798430-5a42021889036_articlex"></p>
<p>更简单的来讲</p>
<p><img src="img%5C2784418971-595ed7833ff78_articlex.jpg" alt="2784418971-595ed7833ff78_articlex"></p>
<p>​        Mobx中有三个核心概念，observable、observer、action。（为了简单没有涉及到computed等概）</p>
<ul>
<li><p>observable:通过observable(state)定义组件的状态，包装后的状态是一个可观察数据（Observable Data）.</p>
</li>
<li><p>observer：通过observer（ReactComponent）定义组件。</p>
</li>
<li><p>action：通过action来修改状态。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 observable 定义组件的状态</span></span><br><span class="line"><span class="keyword">const</span> user = mobx.observable(&#123;</span><br><span class="line">    name: <span class="string">&quot;Jay&quot;</span>,</span><br><span class="line">     age: <span class="number">22</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 action 定义如何修改组件的状态</span></span><br><span class="line"><span class="keyword">const</span> changeName = mobx.action(<span class="function"><span class="params">name</span> =&gt;</span> user.name = name)</span><br><span class="line"><span class="keyword">const</span> changeAge = mobx.action(<span class="function"><span class="params">age</span> =&gt;</span> user.age = age)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 observer 定义 ReactComponent 组件。</span></span><br><span class="line"><span class="keyword">const</span> Hello = mobxReact.observer(<span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 视图层通过事件触发 action</span></span><br><span class="line">        changeName(<span class="string">&#x27;Wang&#x27;</span>) <span class="comment">// render Wang</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">                <span class="comment">// 渲染</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;render&#x27;</span>,user.name);</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello,&#123;user.name&#125;!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Hello</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;mount&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非视图层事件触发，外部直接触发 action</span></span><br><span class="line">changeName(<span class="string">&#x27;Wang2&#x27;</span>)<span class="comment">// render Wang2</span></span><br><span class="line"><span class="comment">// 重点：没有触发重新渲染</span></span><br><span class="line"><span class="comment">// 原因：Hello 组件并没有用到 `user.age` 这个可观察数据</span></span><br><span class="line">changeAge(<span class="string">&#x27;18&#x27;</span>)  <span class="comment">// no console</span></span><br></pre></td></tr></table></figure>

<h4 id="observable"><a href="#observable" class="headerlink" title="observable"></a><strong>observable</strong></h4><p>可观察数据（Observable Data）,可观察数据就是观察到数据的读取、写入，并进行拦截。</p>
<p>Mobx提供了observable接口来定义可观察数据。定义的可观察数据，通常也是组件的状态。该方法接受一个参数，参数可以是原始数据类型、普通Object、Array、或者ES6的Map类型。返回一个observable类型的参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray(mobx.observable([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])) === <span class="literal">false</span> <span class="comment">//true</span></span><br><span class="line">mobx.isObservale(mobx.observable([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])) === <span class="literal">true</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>，数组经过observable包装后，就不是Array类型了，而是Mobx定义的一个特殊observable类型。</p>
<p>虽然数据类型不一样，但是使用方式基本和原来一致（原始数据类型除外）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> observableArr = mobx.observable([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">const</span> observableObj = mobx.observable(&#123;<span class="attr">name</span>: <span class="string">&#x27;Jay&#x27;</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> observableMap = mobx.observable(<span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;Wang&#x27;</span>]]));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(observableArr[<span class="number">0</span>]) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(observableObj.name) <span class="comment">// Jay</span></span><br><span class="line"><span class="built_in">console</span>.log(observableMap.get(<span class="string">&#x27;name&#x27;</span>)) <span class="comment">// wang</span></span><br></pre></td></tr></table></figure>

<p>可观察数据类型的原理是，在读取数据时，通过getter来拦截，在写入数据时，通过setter来拦截</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(o,key,&#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 收集依赖的组件</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 通知依赖的组件更新</span></span><br><span class="line">        value = newValue</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在可观察数据被组件读取时，Mobx会进行拦截，并记录该组件和可观察数据的依赖关系。在可观察数据被写入时，Mobx也会进行拦截，并通知依赖它的组件重新渲染。</p>
<h4 id="observer"><a href="#observer" class="headerlink" title="observer"></a><strong>observer</strong></h4><p>observer接收一个React组件作为参数，并将其转变为响应式（Reactive）组件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通组件</span></span><br><span class="line"><span class="keyword">const</span> Hello = mobxReact.observer(<span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello,&#123;user.name&#125;!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 函数组件</span></span><br><span class="line"><span class="keyword">const</span> Hello = mobxReact.observer(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    &lt;div&gt;Hello,&#123;user.name&#125;!&lt;/div&gt;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>响应式组件，即当且仅当组件依赖的可观察数据发生改变时，组件才回自动响应，并重新渲染。</p>
<h4 id="action"><a href="#action" class="headerlink" title="action"></a><strong>action</strong></h4><p>在Mobx中是可以直接修改可观察数据，来进行更新组件的，但是不建议这样做。如果在任何地方都修改可观察数据，将导致野蛮状态难以管理。</p>
<p>所有对可观察数据的修改，都可以在action中进行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> changeName = mobx.action(<span class="function"><span class="params">name</span> =&gt;</span> user.name = name)</span><br></pre></td></tr></table></figure>

<p>使用Mobx可以将组件状态定义在组件外部，这样，组件逻辑和组件视图很容易分离。兄弟组件之间的状态也很容易同步。另外，也不在需要手动使用shouldComponentUpdate进行性能优化了。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/01/javaWeb/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/01/javaWeb/" class="post-title-link" itemprop="url">javaweb</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-01 11:26:32" itemprop="dateCreated datePublished" datetime="2020-12-01T11:26:32+08:00">2020-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 13:48:31" itemprop="dateModified" datetime="2021-05-27T13:48:31+08:00">2021-05-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>javaweb</p>
<p>web服务器 （tomcat）用来接收客户发来的请求和响应客户请求</p>
<ul>
<li><p>目录结构</p>
</li>
<li><pre><code class="java">bin 存放启动和停止等命令和且其他脚本文件。

config 存放服务器的配置文件

lib 存放服务器的jar包

logs 存放服务器的日志文件

webapps web应用的部署目录

temp  存放tomcat的临时文件

work    tomcat的工作目录
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">编辑器配置好tomcat运行环境</span><br><span class="line"></span><br><span class="line">添加好一个server实例</span><br><span class="line"></span><br><span class="line">servlet  （处理请求和发起响应，为了实现动态页面而衍生出来的）</span><br><span class="line"></span><br><span class="line">servlet 生命周期</span><br><span class="line"></span><br><span class="line">- 加载类</span><br><span class="line">- 初始化</span><br><span class="line">- init</span><br><span class="line">- service</span><br><span class="line">- destory</span><br><span class="line"></span><br><span class="line">servlet与Tomcat之间的关系</span><br><span class="line"></span><br><span class="line">- tomcat是web应用服务器，是一个servlet&#x2F;Jsp容器，负责把请求传递给Servlet，并将Servlet的响应传递给客户。</span><br><span class="line">- servlet是服务器上的一个组件，</span><br><span class="line"></span><br><span class="line">在web.xml中定义servlet与访问网址之间的匹配关系</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;xml</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">	&lt;servlet-name&gt;MyServlet&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;test01.servlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">&lt;&#x2F;servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;MyServlet&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;hello&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;servlet-mapping&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>可以在web.xml中配置load-on-startup=1 服务器启动时初始化servlet对象</p>
<p>servlet初始化参数</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Myservlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>test01.MyServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>haha<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>这是Servlet中的初始参数<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>MyServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>getInitParameterNames()   获取在servlet中的所有初始化参数的名字</p>
<p>重定向</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">&quot;重定向的地址&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>转发</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getDispatcher(<span class="string">&quot;转发的地址&quot;</span>).forWard(request,response)</span><br></pre></td></tr></table></figure>

<h3 id="JSP页面（java-server-pages）本质也是一个servlet"><a href="#JSP页面（java-server-pages）本质也是一个servlet" class="headerlink" title="JSP页面（java server pages）本质也是一个servlet"></a>JSP页面（java server pages）本质也是一个servlet</h3><p> html中写jsp标签，jsp标签中写java代码 </p>
<p>&lt;% java代码%&gt;  &lt;%= java变量%&gt; </p>
<p>html，java代码块，jsp标签组成</p>
<p>JSP中的内置对象</p>
<ul>
<li>out(jspWriter) ：相当于respons.getWriter()获取的对象，用于在页面中显示信息。</li>
<li>config （servletConfig）:   servlet 中的 servletConfig对象。</li>
<li>page (Object) :   对应当前的servlet对象，实际上就是this</li>
<li>pageContext (PageContext) :   当前页面的上下文，也是一个域对象。</li>
<li>exception (Trowable):   错误页面中的异常对象</li>
<li>request （HttpServletRequest）:   HttpServletRequest对象</li>
<li>response  (HttpServletResponse)  :   HttpServletResponse对象</li>
<li>application (ServletContext) :   ServletContext对象</li>
<li>session（HttpSession）:   HttpSession对象</li>
</ul>
<p>EL表达式  自动类型转换</p>
<p>​    EL是jsp内置的表达式语言，用以访问页面的上下文以及不同作用域中的对象 ，取得对象属性的值，或执行简单的运算或判断操作。</p>
<p>​    EL表达式用于代替JSP表达式(&lt;%= %&gt;)在页面中做输出操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EL表达式语法</span><br><span class="line">    $&#123; EL表达式（可完成取值，简单的运算，简单的判断）&#125;</span><br></pre></td></tr></table></figure>

<p>​    EL取值的四个域:<br>​    pageScope<br>​    requestScope<br>​    sessionScope<br>​    applicationScope</p>
<p>EL表达式与JSTL的比较</p>
<ul>
<li>EL表达式为了简化jsp中传统的取值操作。 ${requst.pwd}   &lt;%= request.getAttribute(“pwd”)%&gt;    </li>
<li>JSTL是 （java server pages standard Tag library）</li>
<li>EL表达式多用于取值操作，而JSTL则可以方便我们对集合进行遍历，对数据进行判断等操作</li>
</ul>
<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>avaScript是一种采用事件驱动的脚本语言,它不需要经过Web服务器就可以对用户的输入做出响应</p>
<p>BOM</p>
<p>①Borwser Object Model 浏览器对象模型<br>②浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。BOM由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的子对象<br>③常用的对象(window的子对象)<br>document history location screen navigator frames</p>
<p>DOM</p>
<p>①Document Object Model 文档对象模型<br>②document对象:  window对象的一个属性，代表当前HTML文档，包含了整个文档的树形结构。获 取document对象的本质方法是：window.document，而“window.”可以省略。</p>
<p>document.getElementById(“id值”)</p>
<p>document.getElementsByTagName(“标签名”)</p>
<p>document.getElementsByName(“name值”)</p>
<h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><p>XMLHttpRequest对象是AJAX中非常重要的对象，所有的AJAX操作都是基于该对象的。</p>
<p>Xhr对象的方法</p>
<ul>
<li>①open(method,url,async)      open()用于设置请求的基本信息，接收三个参数<ul>
<li>①method<br>请求的方法：get或post<br>接收一个字符串</li>
<li>②url<br>请求的地址，接收一个字符串</li>
<li>③Assync<br>发送的请求是否为异步请求，接收一个布尔值。<br>true 是异步请求<br>false 不是异步请求（同步请求）</li>
</ul>
</li>
<li>②send(string)<br>send()用于将请求发送给服务器，可以接收一个参数<ul>
<li>①string参数<br>该参数只在发送post请求时需要。<br>string参数用于设置请求体</li>
</ul>
</li>
<li>③setRequestHeader(header,value)<br>用于设置请求头<ul>
<li>①header参数<br>字符串类型，要设置的请求头的名字</li>
<li>②value参数<br>字符串类型，要设置的请求头的值</li>
</ul>
</li>
</ul>
<h3 id="XMLHttpRequest对象的属性"><a href="#XMLHttpRequest对象的属性" class="headerlink" title="XMLHttpRequest对象的属性"></a>XMLHttpRequest对象的属性</h3><p>readyState<br>①描述XMLHttpRequest的状态<br>②一共有五种状态分别对应了五个数字：<br>0 ：请求尚未初始化，open()尚未被调用<br>1 ：服务器连接已建立，send()尚未被调用<br>2 ：请求已接收，服务器尚未响应<br>3 ：请求已处理，正在接收服务器发送的响应<br>4 ：请求已处理完毕，且响应已就绪。<br>2)status<br>①请求的响应码<br>200 响应成功<br>404 页面为找到<br>500 服务器内部错误<br>3)onreadystatechange<br>①该属性需要指向一个函数<br>②该函数会在readyState属性发生改变时被调用<br>4)responseText<br>①获得字符串形式的响应数据。<br>5)responseXML（用的比较少）<br>①获得 XML 形式的响应数据。</p>
<h3 id="使用JQuery框架来发送异步请求"><a href="#使用JQuery框架来发送异步请求" class="headerlink" title="使用JQuery框架来发送异步请求"></a>使用JQuery框架来发送异步请求</h3><ul>
<li><p>JQuery是当前比较主流的 JavaScript 库，封装了很多预定义的对象和实现函数，</p>
</li>
<li><p>JQuery的对象的本质就是dom对象的数组/集合</p>
</li>
<li><p>JQuery对象与dom对象的相互转换<br>JS转JQuery:  var jObj = $(dObj);<br>JQuery转JS:  var dObj = jObj[0] 或者 var dObj = jObj.get(0)</p>
</li>
</ul>
<h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a><strong>Cookie</strong></h3><p>HTTP是无状态协议，服务器不能记录浏览器的访问状态，也就是说服务器不能区分中两次请求是否由一个客户端发出的。假如在我们进行网购时，买了一条裤子，又买了一个手机。由于http协议是无状态的，如果不通过其他手段，服务器是不能知道用户到底买了什么。而Cookie就是解决方案之一。</p>
<p><strong>Cookie实际上就是服务器保存在浏览器上的一段信息</strong>。浏览器有了Cookie之后，每次向服务器发送请求时都会同时将该信息发送给服务器，服务器收到请求后，就可以根据该信息处理请求。</p>
<p>创建cookie</p>
<p>​        Cookie mycookie = new Cookie(‘key’,’value’);</p>
<p>​        mycookie.setPath(‘设置cookie的路径’);</p>
<p>​        mycookie.setMaxAge(‘设置cookie的时间’);</p>
<p>​        request.addCookie(mycookie);</p>
<p>读取cookie</p>
<p>​        Cookie[] cookie = request.getCookie();</p>
<h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a><strong>Session</strong></h3><p>​    使用cookie是有局限的，如果cookie很多会增加数据传输量，浏览器也会对cookie的数量有限制，于是session出现。</p>
<p>​    Session的作用就是在<strong>服务器端</strong>保存一些用户的数据，然后传递给用户一个名字为JSESSIONID的Cookie，这个JESSIONID对应这个服务器中的一个Session对象，通过它就可以获取到保存用户信息的Session。</p>
<ol>
<li><p>Session的工作原理<br>①Session的创建时机是在request.getSession()方法第一次被调用时。<br>②Session被创建后，同时还会有一个名为JSESSIONID的Cookie被创建。<br>③这个Cookie的默认时效就是当前会话。<br>④简单来说，Session机制也是依赖于Cookie来实现的</p>
</li>
<li><p>使用</p>
<p>HttpSession  session = request.getSession();</p>
</li>
<li><p>时效性</p>
<p>可以在web.xml中进行设置 30分钟</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="URL重写"><a href="#URL重写" class="headerlink" title="URL重写"></a>URL重写</h3><p>​    因为session还是需要cookie实现的，如果cookie禁用，则session无法使用，所以我们需要一些备用的手段，如RUL重写。</p>
<ol>
<li><p>URL重写其实就是将JSESSIONID的值以固定格式附着在URL地址后面，以实现保持JSESSIONID，进而保持会话状态。这个固定格式是：URL;jsessionid=xxxxxxxxx</p>
</li>
<li><p>实现方式</p>
<p>String url = “targetServlet”;</p>
<p>String encodeURL = response.encodeURL(url)</p>
<p>response.sendRedirect(encodeURL)</p>
</li>
</ol>
<h2 id="主页面访问权限控制-过滤器-字符转码"><a href="#主页面访问权限控制-过滤器-字符转码" class="headerlink" title="主页面访问权限控制 (过滤器 字符转码)"></a>主页面访问权限控制 (过滤器 字符转码)</h2><ol>
<li><p>对于WEB应用来说，<strong>过滤器是一个驻留在服务器中的WEB组件</strong>，他可以截取客户端和WEB资源之间的请求和响应信息。WEB资源可能包括Servlet、JSP、HTML页面等</p>
</li>
<li><p>当服务器收到特定的请求后，会先将请求交给过滤器，程序员可以在过滤器中对请求信息进行读取修改等操作，然后将请求信息再发送给目标资源。目标资源作出响应后，服务器会再次将响应转交给过滤器，在过滤器中同样可以对响应信息做一些操作，然后再将响应发送给服务器。</p>
</li>
<li><p>使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myFilter</span> <span class="title">implement</span> <span class="title">Filter</span></span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest arg0,Servlet response arg1,FilterChain arg2)</span> <span class="keyword">throws</span> IOException,ServletException </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig arg0)</span> <span class="keyword">throws</span> ServletException</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在xml中配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>loginFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.atguigu.servlet.LoginFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>loginFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="在线人数统计-监听器"><a href="#在线人数统计-监听器" class="headerlink" title="在线人数统计(监听器)"></a>在线人数统计(监听器)</h2><ol>
<li>Listener用于监听JavaWeb程序中的事件。</li>
<li>例如：ServletContext、HttpSession、ServletRequest的创建、修改和删除</li>
<li>监听器的类型分为<br>①生命周期<br>②数据绑定</li>
</ol>
<h2 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h2><p>​    xml用来传输和存储数据，xml没有预定义标签，均为自定义标签。</p>
<ol>
<li>配置文件<br>JavaWeb中的web.xml<br>C3P0中的c3p0-config.xml</li>
<li>数据交换格式<br>Ajax<br>WebService</li>
<li>数据存储<br>保存关系型数据</li>
</ol>
<p>xml组成</p>
<ol>
<li>XML文档组成<br>①XML声明<br>version属性指定XML版本，固定值是1.0<br>encoding指定的字符集，是告诉解析器使用什么字符集进行解码，而编码是由文本 编辑器决定的<br>②CDATA区<br>当XML文档中需要写一些程序代码、SQL语句或其他不希望XML解析器进行解析 的内容时，就可以写在CDATA区中<br>XML解析器会将CDATA区中的内容原封不动的输出<br>CDATA区的定义格式：<![CDATA[…]]></li>
<li>语法规则<br>①XML声明要么不写，要写就写在第一行，并且前面没有任何其他字符<br>②只能有一个根标签<br>③标签必须正确结束<br>④标签不能交叉嵌<br>⑤严格区分大小写<br>⑥属性必须有值，且必须加引号<br>⑦标签不能以数字开头<br>⑧注释不能嵌套</li>
</ol>
<h3 id="xml解析"><a href="#xml解析" class="headerlink" title="xml解析"></a>xml解析</h3><ol>
<li><p>XML解析是指通过解析器读取XML文档，解释语法，并将文档转化成对象</p>
</li>
<li><p>常用的解析方式<br>DOM（Document Object Model）<br>SAX（Simple API for XML）</p>
</li>
<li><p>Dom4j解析示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SAXReader saxreader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">Document document = saxreader.read(<span class="string">&quot;students.xml&quot;</span>)</span><br><span class="line">Element root = document.getRootElement();</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><ol>
<li>AJAX一开始使用的时XML的数据格式，XML的数据格式非常简单清晰，容易编写，但是由于XML中包含了过多的标签，以及十分复杂的结构，解析起来也相对复杂，所以目前来讲，AJAX中已经几乎不使用XML来发送数据了。取而代之的是一项新的技术JSON。</li>
<li>JSON是JavaScript Object Notation 的缩写，是JS提供的一种数据交换格式。</li>
<li>JSON对象本质上就是一个JS对象，但是这个对象比较特殊，它可以直接转换为字符串，在不同语言中进行传递，通过工具又可以转换为其他语言中的对象。</li>
</ol>
<h3 id="JSON通过6种数据类型来表示"><a href="#JSON通过6种数据类型来表示" class="headerlink" title="JSON通过6种数据类型来表示"></a>JSON通过6种数据类型来表示</h3><ol>
<li>字符串</li>
</ol>
<ul>
<li>例子：”字符串”</li>
<li>注意：不能使用单引号</li>
</ul>
<ol>
<li>数字：</li>
</ol>
<ul>
<li>例子：123.4</li>
</ul>
<ol>
<li>布尔值：</li>
</ol>
<ul>
<li>例子：true、false</li>
</ul>
<ol>
<li>null值: </li>
</ol>
<ul>
<li>例子：null</li>
</ul>
<ol>
<li>对象</li>
</ol>
<ul>
<li>例子：{“name”: ”sunwukong”, ”age”: 18}<br>6.数组</li>
<li>例子：[1,”str”,true]</li>
</ul>
<h3 id="在JS中操作JSON"><a href="#在JS中操作JSON" class="headerlink" title="在JS中操作JSON"></a>在JS中操作JSON</h3><ol>
<li>创建JSON对象</li>
</ol>
<ul>
<li>var json = {“name1”: ”value1”,”name2”: ”value2” , “name3”: [1,”str”,true]};</li>
<li>var json = [{“name1”: ”value1”},{“name2”: ”value2”}];</li>
</ul>
<ol>
<li>JSON对象转换为JSON字符串</li>
</ol>
<ul>
<li>JSON.stringify(JSON对象)</li>
</ul>
<ol>
<li>JSON字符串转换为JSON对象</li>
</ol>
<ul>
<li>JSON.parse(JSON字符串)</li>
</ul>
<h3 id="在Java中操作JSON"><a href="#在Java中操作JSON" class="headerlink" title="在Java中操作JSON"></a>在Java中操作JSON</h3><ol>
<li><p>在Java中可以从文件中读取JSON字符串，也可以是客户端发送的JSON字符串，所以第一个问题，我们先来看如何将一个JSON字符串转换成一个Java对象。</p>
</li>
<li><p>首先解析JSON字符串我们需要导入第三方的工具，目前主流的解析JSON的工具大概有三种json-lib、jackson、gson。三种解析工具相比较json-lib的使用复杂，且效率较差。而Jackson和gson解析效率较高。使用简单，这里我们以gson为例讲解。</p>
</li>
<li><p>Gson是Google公司出品的解析JSON工具，使用简单，解析性能好。</p>
</li>
<li><p>Gson中解析JSON的核心是Gson的类，解析操作都是通过该类实例进行。</p>
</li>
<li><p>JSON字符串转换为对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String json = <span class="string">&quot;&#123;\&quot;name\&quot;: \&quot;张三\&quot;，\&quot;age\&quot;: 18&#125;&quot;</span>;</span><br><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line"><span class="comment">// 转换为集合</span></span><br><span class="line">Map&lt;String,Object&gt; stuMap = gson.fromJson(json,Map.class);</span><br><span class="line"><span class="comment">// 转换为类</span></span><br><span class="line">Student student = gson.fromJson(json,Student.class);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>6.对象转json</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Student stu = <span class="keyword">new</span> Student(<span class="string">&quot;李四&quot;</span>, <span class="number">23</span>);</span><br><span class="line">Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line"><span class="comment">//&#123;&quot;name&quot;: &quot;李四&quot;,&quot;age&quot;: 23&#125;</span></span><br><span class="line">String json = gson.toJson(stu);</span><br><span class="line">Map&lt;String , Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">map.put(“name”, “孙悟空”);</span><br><span class="line">map.put(“age”, <span class="number">30</span>);</span><br><span class="line"><span class="comment">//&#123;“age”: 30,“name”: “孙悟空”&#125;</span></span><br><span class="line">String json2 = gson.toJson(map);</span><br><span class="line"></span><br><span class="line">List&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;Student&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> Student(“八戒”, <span class="number">18</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Student(“沙僧”, <span class="number">28</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Student(“唐僧”, <span class="number">38</span>));</span><br><span class="line"><span class="comment">//[&#123;“name”: “八戒”,“age”: 18&#125;,&#123;“name”: “沙僧”,“age”: 28&#125;,</span></span><br><span class="line">&#123;“name”: “唐僧”,“age”: <span class="number">38</span>&#125;]</span><br><span class="line">String json3 = gson.toJson(list);</span><br><span class="line"><span class="comment">// 如果将一个数组格式的json字符串转换成java对象需要用到</span></span><br><span class="line"><span class="comment">//Gson提供的一个匿名内部类： TypeToken</span></span><br><span class="line">TypeToken tk= <span class="keyword">new</span> TypeToken&lt;List&lt;User&gt;&gt;()&#123;&#125;;</span><br><span class="line">List&lt;User&gt; list2 = gson.fromJson(json,tk.getType());</span><br><span class="line">System.out.println(list2.get(<span class="number">0</span>));</span><br></pre></td></tr></table></figure>





<hr>
<p>dao层</p>
<p>service层</p>
<p>web层</p>
<ul>
<li>model  需要向页面加载的数据       一般为javaBean</li>
<li>view   页面模板             一般为jsp</li>
<li>controller  加载哪些数据然后跳转哪个页面         一般为servlet</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/01/js%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/01/js%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">js函数学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-01 11:26:32" itemprop="dateCreated datePublished" datetime="2020-12-01T11:26:32+08:00">2020-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-25 20:15:46" itemprop="dateModified" datetime="2021-03-25T20:15:46+08:00">2021-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="js函数学习"><a href="#js函数学习" class="headerlink" title="js函数学习"></a>js函数学习</h3><ul>
<li><p>var squares = Array(9).fill(null); //创建长度为9的数组</p>
</li>
<li><p>var squaresCope = squares.slice();  //返回一个新的数组，如果指定了start和end参数，则从start到end，否则会全部拷贝。</p>
</li>
<li><p>var newPlayer = Object.assign({},player,{score : 2});  //<code>**Object.assign()**</code> 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。第一个参数为目标对象，后面的都是源对象，源对象和目标对象中有相同的属性，源对象的属性会覆盖目标属性。</p>
</li>
<li><p>array.map(function(currentValue,index,arr),thisValue)  数组中的每个元素都会执行这个函数,thisValue可以省略。</p>
</li>
<li><p>函数表达式会有一个name属性，当没有命名时会将分配变量的名字作为自己的隐式名。</p>
</li>
<li><p>bind()、call()、apply()方法用法,都是用来重定义this这个对象的。<a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/js-call-apply-bind.html">具体区别</a></p>
</li>
<li><p>es6 字符串拼接,可以配合反单引号完成拼接字符串的功能</p>
<p>1、反单引号怎么打出来？<br>将输入法调整为英文输入法，单击键盘上数字键1左边的按键。</p>
<p>2、用法<br>step1： 定义需要拼接进去的字符串变量<br>step2： 将字符串变量用${}包起来，再写到需要拼接的地方</p>
<p>3、示例代码：</p>
<p>let a=’Karry Wang’;</p>
<p>let str=<code>I love $&#123;a&#125;, because he is handsome.</code>;<br>//注意：这行代码是用返单号引起来的</p>
<p>alert(str);<br>一定是用反单引号啊！不要写成单引号了！</p>
</li>
<li><p>opacity属性 （让 DIV 元素半透明）</p>
<p>元素的不透明度级别描述了透明度级别，当不透明度为 1 时表示完全不透明，当不透明度为 0.5 时表示半透明，当不透明度为 0 时表示完全透明。</p>
</li>
<li><p>定时器</p>
<ul>
<li>setInterval() ：按照指定的周期（以毫秒计）来调用函数或计算表达式。方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。（循环定时器）</li>
<li>setTimeout() ：在指定的毫秒数后调用函数或计算表达式。（延时定时器）</li>
</ul>
</li>
<li><p>数组添加删除</p>
<ul>
<li>添加在第一个：unshift(xxx)</li>
<li>删除指定元素:splice(index,number,item)</li>
</ul>
</li>
<li><p><code>  &amp;&amp;</code> 和 <code>||</code> 运算符使用短路逻辑（short-circuit logic），是否会执行第二个语句（操作数）取决于第一个操作数的结果。在需要访问某个对象的属性时，使用这个特性可以事先检测该对象是否为空：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = o &amp;&amp; o.getName();</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>switch</code> 和 <code>case</code> 都可以使用需要运算才能得到结果的表达式；在 <code>switch</code> 的表达式和 <code>case</code> 的表达式是使用 <code>===</code> 严格相等运算符进行比较的：</p>
</li>
<li><p>ES2015 引入了更加简洁的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of"><code>for</code>…<code>of</code></a> 循环，可以用它来遍历可迭代对象，例如数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> currentValue <span class="keyword">of</span> a) &#123;</span><br><span class="line">  <span class="comment">// Do something with currentValue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ECMAScript 5 增加了另一个遍历数组的方法，<code>forEach()</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&quot;dog&quot;</span>, <span class="string">&quot;cat&quot;</span>, <span class="string">&quot;hen&quot;</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">currentValue, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Do something with currentValue or array[index]</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>数组函数 </p>
<p>shift   \ unshift  \ push  \ pop  \ concat \join  \ length  \ splice \ </p>
</li>
<li><p>js取非行间样式</p>
<ul>
<li>getComputedStyle(obj,false)[‘attr’]方法</li>
<li>div.currentStyle[‘width’];方法</li>
</ul>
</li>
<li><p>dom节点</p>
<ul>
<li>childNodes  \ nodeType</li>
<li>children  //好用</li>
</ul>
</li>
<li><p>String</p>
<ul>
<li>search方法</li>
</ul>
</li>
<li><p>事件冒泡</p>
<ul>
<li>event.cancelBubble=true</li>
<li>鼠标位置  clinetX,clientY</li>
<li>键盘按键  keyCode</li>
<li>其他属性  boolean值   ctrlKey  shiftKey   altKey</li>
</ul>
</li>
<li><p>默认行为</p>
<ul>
<li>documemnt.oncontextmenu=()=&gt;{return false;}</li>
<li>otxt.onkeydown=()=&gt;{return false}</li>
<li>计算窗口的高度document.documentElement.clientHeight</li>
<li>计算物体自己的高度 document.documentElement.clientWidth</li>
</ul>
</li>
<li><p>事件绑定</p>
<ul>
<li>attachEvent(‘onclick’,函数)</li>
<li>addEventListener(‘click’,函数,false)</li>
</ul>
</li>
<li><p>事件捕获</p>
<ul>
<li>setCapture()  ie浏览器下</li>
</ul>
</li>
<li><p>AJAX</p>
<ul>
<li><p>创建Ajax对象  var oAjax = new XMLHttpRequest();</p>
</li>
<li><p>链接服务器   oAjax.open()     |   open(方法,文件名,异步传输)</p>
</li>
<li><p>发送请求   oAjax.send()</p>
</li>
<li><p>接受返回值  oAjax.onreadystatechange = function(){</p>
<p>oAjax.readystate // 浏览器和服务器进行到哪一步了 </p>
</li>
<li><p>};</p>
</li>
<li><p>看看是否成功  oAjax.status==200</p>
</li>
<li><p>查看返回的文本   oAjax.responseText</p>
</li>
</ul>
</li>
<li><p>原型</p>
<ul>
<li>prototype   | 用法   类.prototy.属性  (集体添加上属性)</li>
</ul>
</li>
<li><p>继承</p>
<ul>
<li>A继承B的属性     在A的函数中添加B.call(this)</li>
<li>A继承B的方法      A.prototype=B.prototype;</li>
</ul>
</li>
<li><p>Generator函数(函数名后有*号,用yeild表达式来表示)用来生成iterator表达式 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">myGenerator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    yeild <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">    yeild <span class="string">&#x27;generator&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> MG = myGenerator(); <span class="comment">// 这里生成一个Generator函数</span></span><br><span class="line">MG.next();<span class="comment">// 第一种方法</span></span><br><span class="line"><span class="function"><span class="title">for</span>(<span class="params"> <span class="keyword">var</span> a <span class="keyword">of</span> MG</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>promise函数(可以保存状态，pending,从pending变为fulfilled<br>从pending变为rejected)</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url:<span class="string">&#x27;data/json.txt&#x27;</span>,</span><br><span class="line">        dataType: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">        <span class="function"><span class="title">success</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">            resolve(arr);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">error</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">            reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;成功了&#x27;</span>+arr);</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;失败了&#x27;</span>)；</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>export和module.export(还是不太了解)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span> 是 <span class="built_in">module</span>.exports 的一个引用</span><br><span class="line"><span class="built_in">module</span>.exports 初始值为一个空对象 &#123;&#125;，所以 <span class="built_in">exports</span> 初始值也是 &#123;&#125;</span><br><span class="line"><span class="built_in">require</span> 引用模块后，返回的是 <span class="built_in">module</span>.exports 而不是 <span class="built_in">exports</span>!!!!!</span><br><span class="line"><span class="built_in">exports</span>.xxx 相当于在导出对象上挂属性，该属性对调用模块直接可见</span><br><span class="line"><span class="built_in">exports</span> = 相当于给 <span class="built_in">exports</span> 对象重新赋值，调用模块不能访问 <span class="built_in">exports</span> 对象及其属性</span><br><span class="line">如果此模块是一个类，就应该直接赋值 <span class="built_in">module</span>.exports，这样调用者就是一个类构造器，可以直接 <span class="keyword">new</span> 实例。</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>html 中rel属性</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>alternate</td>
<td>文档的可选版本（例如打印页、翻译页或镜像）。</td>
</tr>
<tr>
<td>stylesheet</td>
<td>文档的外部样式表。</td>
</tr>
<tr>
<td>start</td>
<td>集合中的第一个文档。</td>
</tr>
<tr>
<td>next</td>
<td>集合中的下一个文档。</td>
</tr>
<tr>
<td>prev</td>
<td>集合中的前一个文档。</td>
</tr>
<tr>
<td>contents</td>
<td>文档目录。</td>
</tr>
<tr>
<td>index</td>
<td>文档索引。</td>
</tr>
<tr>
<td>glossary</td>
<td>文档中所用字词的术语表或解释。</td>
</tr>
<tr>
<td>copyright</td>
<td>包含版权信息的文档。</td>
</tr>
<tr>
<td>chapter</td>
<td>文档的章。</td>
</tr>
<tr>
<td>section</td>
<td>文档的节。</td>
</tr>
<tr>
<td>subsection</td>
<td>文档的子段。</td>
</tr>
<tr>
<td>appendix</td>
<td>文档附录。</td>
</tr>
<tr>
<td>help</td>
<td>帮助文档。</td>
</tr>
<tr>
<td>bookmark</td>
<td>相关文档。</td>
</tr>
<tr>
<td>nofollow</td>
<td>Google 使用 “nofollow”，用于指定 Google 搜索引擎不要跟踪链接。</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="js解构"><a href="#js解构" class="headerlink" title="js解构"></a>js解构</h3><p>​    可以查看<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment</a></p>
<h3 id="React-Fragment（简写-lt-gt-lt-gt-）"><a href="#React-Fragment（简写-lt-gt-lt-gt-）" class="headerlink" title="React.Fragment（简写&lt;&gt;&lt;/&gt;）"></a>React.Fragment（简写&lt;&gt;&lt;/&gt;）</h3><p>​    片段(fragments) 可以让你将子元素列表添加到一个分组中，并且<code>不会在DOM中增加额外节点</code>（还可以使用返回数组的方式来解决。）;您可以像使用其他元素一样使用<code>&lt;&gt;&lt;/&gt;</code>，只是它不支持 键(keys) 或 属性(attributes)。</p>
<h3 id="插槽-Portals"><a href="#插槽-Portals" class="headerlink" title="插槽(Portals)"></a>插槽(Portals)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.createPortal(child, container)</span><br></pre></td></tr></table></figure>

<p>​    第一个参数（child）是任何可渲染的 React 子元素，例如一个元素，字符串或 片段(fragment)。第二个参数（container）则是一个 DOM 元素。</p>
<p><code>    对于 portal 的一个典型用例是当父组件有 overflow: hidden 或 z-index 样式，但你需要子组件能够在视觉上 “跳出(break out)” 其容器。</code>例如，对话框、hovercards以及提示框。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>​    </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/01/js%E5%B0%8F%E6%8A%80%E5%B7%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/01/js%E5%B0%8F%E6%8A%80%E5%B7%A7/" class="post-title-link" itemprop="url">js小技巧</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-01 11:26:32" itemprop="dateCreated datePublished" datetime="2020-12-01T11:26:32+08:00">2020-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-25 20:15:23" itemprop="dateModified" datetime="2021-03-25T20:15:23+08:00">2021-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>js小技巧</p>
<ul>
<li><p><code>&amp;&amp;</code> 和 <code>||</code> 运算符使用短路逻辑（short-circuit logic），是否会执行第二个语句（操作数）取决于第一个操作数的结果。在需要访问某个对象的属性时，使用这个特性可以事先检测该对象是否为空：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = o &amp;&amp; o.getName();</span><br></pre></td></tr></table></figure>
</li>
<li><p>或用于缓存值（当错误值无效时）：</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = cachedName || (cachedName = getName());</span><br></pre></td></tr></table></figure>

<ul>
<li>类似地，JavaScript 也有一个用于条件表达式的三元操作符：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> allowed = (age &gt; <span class="number">18</span>) ? <span class="string">&quot;yes&quot;</span> : <span class="string">&quot;no&quot;</span>;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/01/react/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/01/react/" class="post-title-link" itemprop="url">react学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-01 11:26:32" itemprop="dateCreated datePublished" datetime="2020-12-01T11:26:32+08:00">2020-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-25 20:14:49" itemprop="dateModified" datetime="2021-03-25T20:14:49+08:00">2021-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1、react初步了解"><a href="#1、react初步了解" class="headerlink" title="1、react初步了解"></a>1、react初步了解</h1><h3 id="1、特点"><a href="#1、特点" class="headerlink" title="1、特点"></a>1、特点</h3><ul>
<li>声明式 ：我们只需要更新数据就可以了，不用亲自操作dom元素。</li>
<li>组件化 ：将页面分为一个个的组建，易于编写和维护。</li>
</ul>
<h3 id="2、高效的原因"><a href="#2、高效的原因" class="headerlink" title="2、高效的原因"></a>2、高效的原因</h3><ul>
<li>虚拟dom，不总是直接操作DOM。以前是一个一个修改DOM，虚拟DOM与DOM对象一一对应，更改虚拟DOM并不会直接更改DOM，而是等待都更改完成，批量更改。</li>
<li>DOM Diff 算法，最小化页面重绘。</li>
</ul>
<h3 id="3、引入库文件"><a href="#3、引入库文件" class="headerlink" title="3、引入库文件"></a>3、引入库文件</h3><p>​        <a href="www.bootcdn.cn">开源库</a></p>
<p>​        react-dom.development.js（提供操作DOM对象的react扩展库）、react.development.js(react核心库)、babel.js(把ES6改为ES5或解析jsx语法为js语法)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;test&quot;&gt;</span><br><span class="line">    </span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;..&#x2F;js&#x2F;react.development.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;..&#x2F;js&#x2F;react-dom.development.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;..&#x2F;js&#x2F;babel.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;babel&quot;&gt;</span><br><span class="line">&#x2F;&#x2F;1、创建虚拟DOM元素对象</span><br><span class="line">var vDom &#x3D; &lt;h1&gt;Hello React!&lt;&#x2F;h1&gt;</span><br><span class="line">&#x2F;&#x2F;2、将虚拟DOM渲染到页面真是DOM对象中</span><br><span class="line">ReactDOM.render(vDom,document.getElementById(&#39;test&#39;))</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="2、了解jsx"><a href="#2、了解jsx" class="headerlink" title="2、了解jsx"></a>2、了解jsx</h1><h3 id="1、不使用jsx创建虚拟DOM对象"><a href="#1、不使用jsx创建虚拟DOM对象" class="headerlink" title="1、不使用jsx创建虚拟DOM对象"></a>1、不使用jsx创建虚拟DOM对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var element &#x3D; React.creatElement(&#39;h1&#39;,&#123;id:&#39;myTitle&#39;&#125;,&#39;hello&#39;)</span><br></pre></td></tr></table></figure>

<p>如果要使用变量中定义的内容，要使用{ }将变量包起来。</p>
<p>再js中可以使用debugger来设置断点。</p>
<p>在React组件的构造函数中设置this.state来初始化state。</p>
<h3 id="2、自定义组件"><a href="#2、自定义组件" class="headerlink" title="2、自定义组件"></a>2、自定义组件</h3><h4 id="1、定义组件"><a href="#1、定义组件" class="headerlink" title="1、定义组件"></a>1、定义组件</h4><p>方式一、工厂函数组件</p>
<p>function MyComponent(){</p>
<p>​    return </p>
<p>}</p>
<p>方式二、es6类组件</p>
<p>class MyComponent2 extends React.Component{</p>
<p>​    render(){</p>
<p>​        return </p>
<p>​    }</p>
<p>}</p>
<h4 id="2、渲染组件标签"><a href="#2、渲染组件标签" class="headerlink" title="2、渲染组件标签"></a>2、渲染组件标签</h4><p>ReactDOM.render(<MyComponent/>,document.getElementById(‘example1’))</p>
<h4 id="3、组件的三打属性"><a href="#3、组件的三打属性" class="headerlink" title="3、组件的三打属性"></a>3、组件的三打属性</h4><ul>
<li><pre><code class="javascript">const &#123;isNext&#125; = this.state //es6写法，等同年与 const isNext = this.state.isNext
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;js</span><br><span class="line">  const isNext &#x3D; !this.state.isNext</span><br><span class="line">  this.setState(&#123;isNext&#125;) &#x2F;&#x2F;es6写法,等同于isNext &#x3D; isNext</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h6 id="①state"><a href="#①state" class="headerlink" title="①state"></a>①state</h6><p>​        是一个对象，如果用它则必须使用类组件的方式。在constructor（）方法中定义。可以使用setState（{xxx  = xxx}）方式来更新数据，用这种方式更新数据，所有的用到该数据的地方都会进行更新。</p>
<h6 id="②props"><a href="#②props" class="headerlink" title="②props"></a>②props</h6><p>​        是一个对象，用来将数据从组件外传入到组件内部。</p>
<p><strong>指定默认值</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定属性默认值</span></span><br><span class="line">Person.defaultProps = &#123;</span><br><span class="line">    sex: <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">    age:<span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <strong>props验证</strong></p>
<p>​    React.PropTypes 在 React v15.5 版本后已经移到了 <strong>prop-types</strong> 库。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://cdn.bootcss.com/prop-types/15.6.1/prop-types.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对props中的属性值济宁类型限制和必要性限制</span></span><br><span class="line">Person.propTypes = &#123;</span><br><span class="line">    name:PropTypes.string.isRequired,</span><br><span class="line">    age:PropTypes.number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*  ...的作用</span></span><br><span class="line"><span class="comment">* 1、打包 </span></span><br><span class="line"><span class="comment">* 2、解包</span></span><br><span class="line"><span class="comment">* ReactDOM.render(&lt;Person &#123;...p1&#125;/&gt;,document.getElementById(&#x27;test&#x27;))</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure>

<h6 id="③refs"><a href="#③refs" class="headerlink" title="③refs"></a>③refs</h6><p><strong>作用</strong>:    React 支持一种非常特殊的属性 <strong>Ref</strong> ，你可以用来绑定到 render() 输出的任何组件上。</p>
<p>这个特殊的属性允许你引用 render() 返回的相应的支撑实例（ backing instance ）。这样就可以确保</p>
<p>在任何时间总是拿到正确的实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;input ref = ‘content<span class="string">&#x27;&gt;&lt;/input&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">const input = this.refs.content</span></span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;opacity:opacity&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>外边的大括号代表进行书写js文件，里面的括号代表这是一个对象。</p>
<h4 id="react-ajax"><a href="#react-ajax" class="headerlink" title="react ajax"></a>react ajax</h4><p>react本身没有提供ajax相关的代码。</p>
<p>解决方法：</p>
<ul>
<li><p>1、jQuery：比较重，不建议使用</p>
</li>
<li><p>2、axios：轻量级，建议使用</p>
<ul>
<li>封装XmlHttpRequest对象的ajax</li>
<li>promise风格</li>
<li>可以用在浏览器端和node服务器端</li>
</ul>
</li>
<li><p>3、fetch：原生函数，但老版本浏览器不支持</p>
<ul>
<li>不再使用XmlHttpRequest对象提交的ajax请求</li>
<li>为了兼容低版本的浏览器，可以引入兼容库fetch.js</li>
</ul>
</li>
</ul>
<h4 id="兄弟组件之间传递信息"><a href="#兄弟组件之间传递信息" class="headerlink" title="兄弟组件之间传递信息"></a>兄弟组件之间传递信息</h4><p>组件：pubsub-js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PubSub <span class="keyword">from</span> <span class="string">&#x27;pubsub-js&#x27;</span></span><br><span class="line"></span><br><span class="line">PubSub.publish(<span class="string">&#x27;name&#x27;</span>,data)</span><br><span class="line"></span><br><span class="line">PubSub.subscribe(<span class="string">&#x27;name&#x27;</span>,<span class="function">(<span class="params">name,data</span>)=&gt;</span>&#123;</span><br><span class="line">	hanshu </span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="如何编写路由效果"><a href="#如何编写路由效果" class="headerlink" title="如何编写路由效果"></a>如何编写路由效果</h4><ol>
<li>编写路由组件</li>
<li>在父路由组件中指定<ul>
<li>路由链接：<NavLink></li>
<li>路由：<Route></li>
</ul>
</li>
</ol>
<h4 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h4><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200624105238185.png" alt="image-20200624105238185"></p>
<p>1.安装redex</p>
<p>​        npm install –save redux</p>
<p>2.API</p>
<ul>
<li>creatStore()</li>
</ul>
<p>3.对象</p>
<ul>
<li>store<ul>
<li>作用:redux库最核心的管理对象</li>
<li>内部属性<ul>
<li>state 公共状态</li>
<li>reducer 改变状态的函数</li>
</ul>
</li>
<li>方法<ul>
<li>getState()</li>
<li>dispatch(action)</li>
<li>subscribe(listener)</li>
</ul>
</li>
<li>编码<ul>
<li>store.getState() //获取状态数据</li>
<li>store.dispatch({type:’INCREMENT’,number}) //进行状态数据更改</li>
<li>store.subscribe(render) //状态数据更改后要重新执行渲染</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>4.核心概念</p>
<ul>
<li><p>action(用来表示执行行为的对象)</p>
<ul>
<li>属性<ul>
<li>type:标识属性,值为字符串,唯一</li>
<li>xxx:数据属性,值类型任意 </li>
</ul>
</li>
<li>Action Creator(创建Action的函数)</li>
</ul>
</li>
<li><p>reducer(根据老的state和action,产生新的state的纯函数)</p>
<ul>
<li>function xxx(state=0,action){ //根据action的type判断执行那些操作}</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建reducer</span></span><br><span class="line"><span class="keyword">import</span> &#123;INCREMENT,DECREMENT&#125; <span class="keyword">from</span> <span class="string">&quot;./action-type&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span>  <span class="function"><span class="keyword">function</span> <span class="title">counter</span>(<span class="params">state = <span class="number">0</span>,action</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;counter()&#x27;</span>,state,action)</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> INCREMENT:</span><br><span class="line">            <span class="keyword">return</span> state + action.data</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span>  DECREMENT:</span><br><span class="line">            <span class="keyword">return</span> state - action.data</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.创建store</span></span><br><span class="line"><span class="keyword">import</span> &#123;createStore&#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;counter&#125; <span class="keyword">from</span> <span class="string">&quot;./reducers&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> store = createStore(counter)</span><br><span class="line"><span class="comment">//2.1传递和使用store</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;/</span>&gt;</span></span>,<span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.2初始化渲染</span></span><br><span class="line">render()</span><br><span class="line"><span class="comment">//2.3订阅监听(store中的状态变化了,就会自动调用)</span></span><br><span class="line">store.subscribe(</span><br><span class="line">    render()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.actionsCreactor actions工厂创建</span></span><br><span class="line"><span class="keyword">import</span> &#123;INCREMENT,DECREMENT&#125; <span class="keyword">from</span> <span class="string">&quot;./action-type&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> increment = <span class="function">(<span class="params">number</span>)=&gt;</span>(&#123;<span class="attr">type</span>:INCREMENT,<span class="attr">data</span>:number&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> decrement = <span class="function">(<span class="params">number</span>)=&gt;</span>(&#123;<span class="attr">type</span>:INCREMENT,<span class="attr">data</span>:number&#125;)</span><br><span class="line"><span class="comment">//4.插件中使用</span></span><br><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;INCREMENT,DECREMENT&#125; <span class="keyword">from</span> <span class="string">&quot;../action-type&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">&quot;../actions&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    increment = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//1.读取选择的值</span></span><br><span class="line">        <span class="keyword">const</span> number = <span class="built_in">this</span>.select.value*<span class="number">1</span></span><br><span class="line">        <span class="comment">//2.调用store的方法更新状态</span></span><br><span class="line">        <span class="built_in">this</span>.props.store.dispatch(actions.increment(number))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    decrement = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//1.读取选择的值</span></span><br><span class="line">        <span class="keyword">const</span> number = <span class="built_in">this</span>.select.value*<span class="number">1</span></span><br><span class="line">        <span class="comment">//2.调用store的方法更新状态</span></span><br><span class="line">        <span class="built_in">this</span>.props.store.dispatch(actions.decrement(number))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    incrementIfOdd = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//1.读取选择的值</span></span><br><span class="line">        <span class="keyword">const</span> number = <span class="built_in">this</span>.select.value*<span class="number">1</span></span><br><span class="line">        <span class="comment">//2.获取count的值</span></span><br><span class="line">        <span class="keyword">const</span> count = <span class="built_in">this</span>.props.store.getState()</span><br><span class="line">        <span class="comment">//3.更新count</span></span><br><span class="line">        <span class="keyword">if</span> (count%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.props.store.dispatch(actions.increment(number))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    incrementAsync = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//1.读取选择的值</span></span><br><span class="line">        <span class="keyword">const</span> number = <span class="built_in">this</span>.select.value*<span class="number">1</span></span><br><span class="line">        <span class="comment">//2.加上count的值</span></span><br><span class="line">        <span class="keyword">const</span> count = <span class="built_in">this</span>.props.store.getState()</span><br><span class="line">        <span class="comment">//3.更新count</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.props.store.dispatch(actions.increment(number))</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> count = <span class="built_in">this</span>.props.store.getState()</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;p&gt;click &#123;count&#125; times&lt;/p&gt;</span><br><span class="line">                &lt;div&gt;</span><br><span class="line">                    &lt;select ref=&#123;<span class="function"><span class="params">select</span>=&gt;</span><span class="built_in">this</span>.select = select&#125;&gt;</span><br><span class="line">                        &lt;option value=<span class="string">&quot;1&quot;</span>&gt;<span class="number">1</span>&lt;/option&gt;</span><br><span class="line">                        &lt;option value=<span class="string">&quot;2&quot;</span>&gt;<span class="number">2</span>&lt;/option&gt;</span><br><span class="line">                        &lt;option value=<span class="string">&quot;3&quot;</span>&gt;<span class="number">3</span>&lt;/option&gt;</span><br><span class="line">                    &lt;/select&gt;&amp;nbsp;</span><br><span class="line">                    &lt;button onClick=&#123;<span class="built_in">this</span>.increment&#125;&gt;+&lt;/button&gt;&amp;nbsp;</span><br><span class="line">                    &lt;button onClick=&#123;<span class="built_in">this</span>.decrement&#125;&gt;-&lt;/button&gt;&amp;nbsp;</span><br><span class="line">                    &lt;button onClick=&#123;<span class="built_in">this</span>.incrementIfOdd&#125;&gt;increment <span class="keyword">if</span> odd&lt;/button&gt;&amp;nbsp;</span><br><span class="line">                    &lt;button onClick=&#123;<span class="built_in">this</span>.incrementAsync&#125;&gt;increment <span class="keyword">async</span>&lt;/button&gt;&amp;nbsp;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="使用react-redux简化-就是使用传参的方式传递state和改变state函数"><a href="#使用react-redux简化-就是使用传参的方式传递state和改变state函数" class="headerlink" title="使用react-redux简化(就是使用传参的方式传递state和改变state函数)"></a>使用react-redux简化(就是使用传参的方式传递state和改变state函数)</h4><ul>
<li>引入  <code>npm install --save react-redux</code></li>
<li>在index中 用Provider包装组件</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Provider&#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">	&lt;Provider store = &#123;store&#125;&gt; <span class="comment">//store不在给App组件,而是给Provider组件</span></span><br><span class="line">    	&lt;App/&gt;</span><br><span class="line">    &lt;/Provider&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>在App组件中</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;increment,decrement&#125; <span class="keyword">from</span> <span class="string">&quot;../actions&quot;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="title">extents</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;<span class="comment">//不是直接暴露出来</span></span><br><span class="line">    <span class="keyword">static</span> propTypes = &#123; <span class="comment">// 判断参数</span></span><br><span class="line">        count:PropTypes.number.isRequired,</span><br><span class="line">        incrememt:PropTypes.func.isRequired,</span><br><span class="line">        decrement:PropTypes.func.isRequired</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">    incrementIfOdd = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//1.读取选择的值</span></span><br><span class="line">        <span class="keyword">const</span> number = <span class="built_in">this</span>.select.value*<span class="number">1</span></span><br><span class="line">        <span class="comment">//2.获取count的值</span></span><br><span class="line">        <span class="keyword">const</span> count = <span class="built_in">this</span>.props.count<span class="comment">//这里获取的是props中的count不是在store获取</span></span><br><span class="line">        <span class="comment">//3.更新count</span></span><br><span class="line">        <span class="keyword">if</span> (count%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.props.incrememt(number)<span class="comment">//这里直接使用参数中的函数,不是在使用store.dispatch(action)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(</span><br><span class="line">	state=&gt;(&#123;<span class="attr">count</span>:state&#125;),</span><br><span class="line">    &#123;increment,decrement&#125;</span><br><span class="line">)(<span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>) <span class="comment">//这里使用connect函数给App插件绑定参数,第一个括号是执行connect函数,参数为要绑定的参数,返回是一个函数.然后在把App插件作为参数传递过去,返回一个绑定好参数的插件.使用export导出去</span></span><br></pre></td></tr></table></figure>

<ul>
<li>react-redux分为component和container<ul>
<li>component不包含redux内容的部分</li>
<li>container是包含redux内容的部分</li>
</ul>
</li>
</ul>
<h4 id="redux异步编程"><a href="#redux异步编程" class="headerlink" title="redux异步编程"></a>redux异步编程</h4><ul>
<li><p>下载redux插件(异步编程中间件)</p>
<p><code>npm  install --save redux-thunk</code></p>
</li>
<li><p>在store.js中添加applyMiddleware和thunk</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createStore,applyMiddleware&#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;counter&#125; <span class="keyword">from</span> <span class="string">&quot;./reducers&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(counter,applyMiddleware(thunk)) <span class="comment">//应用上异步中间件</span></span><br><span class="line"><span class="keyword">export</span>  <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>
</li>
<li><p>在插件中异步函数使用this.props.incrementAsync()函数</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">incrementAsync = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//1.读取选择的值</span></span><br><span class="line">    <span class="keyword">const</span> number = <span class="built_in">this</span>.select.value*<span class="number">1</span></span><br><span class="line">    <span class="built_in">this</span>.props.incrementAsync(number)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在container中app.js中(也就是绑定参数的函数的js文件)添加incrementAsync函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;decrement, increment,incrementAsync&#125; <span class="keyword">from</span> <span class="string">&quot;../actions&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Counter <span class="keyword">from</span> <span class="string">&quot;../components/counter&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>  connect(</span><br><span class="line">    state =&gt;(&#123;<span class="attr">count</span>:state&#125;),</span><br><span class="line">    &#123;increment,decrement,incrementAsync&#125;</span><br><span class="line">)(Counter)</span><br></pre></td></tr></table></figure>

<ul>
<li>在actions文件中添加函数(注意异步函数返回的是一个函数)</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">包含所有action creator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> &#123;INCREMENT,DECREMENT&#125; <span class="keyword">from</span> <span class="string">&quot;./action-type&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;number&#125; <span class="keyword">from</span> <span class="string">&quot;prop-types&quot;</span>;</span><br><span class="line"><span class="comment">//同步的action都是返回一个对象</span></span><br><span class="line"><span class="comment">//异步的action都是返回一个函数</span></span><br><span class="line"><span class="comment">//增加</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> increment = <span class="function">(<span class="params">number</span>)=&gt;</span>(&#123;<span class="attr">type</span>:INCREMENT,<span class="attr">data</span>:number&#125;)</span><br><span class="line"><span class="comment">//减少</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> decrement = <span class="function">(<span class="params">number</span>)=&gt;</span>(&#123;<span class="attr">type</span>:DECREMENT,<span class="attr">data</span>:number&#125;)</span><br><span class="line"><span class="comment">//异步增加</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> incrementAsync = <span class="function">(<span class="params">number</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">dispatch</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">//异步的代码</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">            dispatch(increment(number))</span><br><span class="line">            <span class="comment">// 1s之后才去分发一个action</span></span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E9%9F%A9%E5%BF%97%E5%B9%B3%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E9%9F%A9%E5%BF%97%E5%B9%B3%EF%BC%89/" class="post-title-link" itemprop="url">数据结构与算法（韩志平）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-01 11:26:32" itemprop="dateCreated datePublished" datetime="2020-12-01T11:26:32+08:00">2020-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-03-25 20:13:12" itemprop="dateModified" datetime="2021-03-25T20:13:12+08:00">2021-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="线性结构：特点数据元素之间存在一对一的关系（数组、队列、链表、栈）"><a href="#线性结构：特点数据元素之间存在一对一的关系（数组、队列、链表、栈）" class="headerlink" title="线性结构：特点数据元素之间存在一对一的关系（数组、队列、链表、栈）"></a>线性结构：特点数据元素之间存在一对一的关系（数组、队列、链表、栈）</h3><p>​        两种不同的存储结构，顺序存储结构（顺序表）和链式存储结构（链表）</p>
<h3 id="非线性结构：（二维数组、多维数组、广义表、树结构、图结构）"><a href="#非线性结构：（二维数组、多维数组、广义表、树结构、图结构）" class="headerlink" title="非线性结构：（二维数组、多维数组、广义表、树结构、图结构）"></a>非线性结构：（二维数组、多维数组、广义表、树结构、图结构）</h3><h5 id="稀疏数组-（当二维数组中存在多个一样的值得时候使用）"><a href="#稀疏数组-（当二维数组中存在多个一样的值得时候使用）" class="headerlink" title="稀疏数组 （当二维数组中存在多个一样的值得时候使用）"></a>稀疏数组 （当二维数组中存在多个一样的值得时候使用）</h5><ul>
<li>第一行几行几列有多少个不同的元素</li>
<li>剩下的是不同元素所在的行和列以及值</li>
</ul>
<p><img src="%E5%9B%BE%E7%89%87%5Cimage-20210310172143830.png" alt="image-20210310172143830"></p>
<p>josephu(约瑟夫)问题（丢手帕问题）</p>
<p>单项环形链表</p>
<p>最小生成树（普利姆算法）</p>
<p>最短路径问题（图+弗洛伊德算法）</p>
<p>汉诺塔 分治算法</p>
<p>八皇后算法  回溯算法</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/01/java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/01/java/" class="post-title-link" itemprop="url">java学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-01 11:26:32" itemprop="dateCreated datePublished" datetime="2020-12-01T11:26:32+08:00">2020-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-20 16:51:58" itemprop="dateModified" datetime="2021-05-20T16:51:58+08:00">2021-05-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>java</p>
<p>java构造赋值，先父类后子类，先默认后构造的顺序。</p>
<p>父类与子类：</p>
<p>​         子父类拥有相同的变量，规则：自己有用自己，自己无用父类。</p>
<pre><code>     父类实现先于子类实现，显式调用父类构造器或者隐藏调用父类无参构造器</code></pre>
<p>​    Serializable接口，相当于一个标志，告诉jvm可以将该类的对象进行序列化和反序列化。（可以使用transient修饰那些不需要序列化的属性），最好自己写一个serialVersionUID(static final long)，不会序列化static关键字修饰的属性。如果父类没有实现Serializable接口，那么必须有无参构造函数。</p>
<p>​    Externalizable接口，需要重写writeExternal和readExternal方法,效率比Serializable高，可以决定哪些属性需要序列化（即使transient修饰的），但是面对大量对象，或者重复对象，则效率低。</p>
<p>​    package打包后的类可以不在同一个文件夹中，但是所在文件夹的名字必须与包名一致。</p>
<p>​    import关键字，使用*号时，只会导入该包内的类，并不会导入包。</p>
<p>​    </p>
<p>抽象类：</p>
<p>​    防止创建没有对象性质的对象（例如：动物），只应该有方法声明，不应该有方法主题。</p>
<p>​    抽象类也是具有构造函数的，所有子类实现都必须先执行抽象类的构造函数。</p>
<p>​    抽象类中可以存在0到多个抽象方法，也可存在0到多个非抽象方法</p>
<p>接口：</p>
<p>​    接口是一种特殊的抽象类，也是引用数据类型（数组，类，接口）,包含抽象方法( public abstract)，（静态方法和默认方法(default不可省)）jdk8以后，成员属性都是常量（public static final）</p>
<p>​    默认方法，子类不需要重写。</p>
<p>​    实现接口是为了实现某个功能，是为了进行拓展。</p>
<p>类中代码会在属性初始化之后，无参构造函数之前</p>
<p>static</p>
<p>​    static 关键字修饰的 可以继承 但是不可以重写</p>
<p>final    </p>
<p>​    final 修饰成员变量必须赋值（直接赋值，代码块赋值，构造方法赋值），修饰局部变量可以声明和赋值分开。</p>
<p>​    final修饰的形参也是不能改变的</p>
<p>​    final 修饰引用类型，可以更改引用对象。</p>
<p>​    static final 修饰的就是一个常量  （直接赋值，静态代码块赋值）</p>
<p>​    final 修饰的方法不允许被重写</p>
<p>​    final 修饰的类不能被继承</p>
<p>多态</p>
<p>​    成员属性看左边，成员方法看右边（方法里面用右边变量）</p>
<p>Hashcode编码</p>
<p>​    用的Object.hash(Object… values)   底层 Arrays.hashCode(values)</p>
<p>实现clone方法</p>
<p>​    实现Cloneable接口,才能重写Object类的clone方法</p>
<p>javaBean规范</p>
<p>​    必须要有包</p>
<p>​    属性私有化</p>
<p>​    get、set方法</p>
<p>​    实现接口序列化  Serializable</p>
<p>​    public修饰类</p>
<p>​    增加无参构造函数</p>
<p>String类</p>
<p>​    底层char数组，String对象永远不变</p>
<p>​    字符串池的存在，所以字符串字面量是共享的</p>
<p>​    底层是char数组，所以可以进行char数组和字符串的互转</p>
<p>​    intern方法: （手动优化）如果字符串池中有则返回字符串池中得，否则向池中添加再返回</p>
<p>​    match方法：正则表达式</p>
<p>StringBuilder（异步，不安全）</p>
<p>​    append: 添加</p>
<p>​    insert: 插入位置的前面</p>
<p>​    delete: 删除包前不包后</p>
<p>正则表达式的作用</p>
<p>​    判断句子是否符合你的规则   match</p>
<p>​    按照你的规则进行文本切割   split</p>
<p>​    在文本中替换你想要得格式    replaceAll</p>
<p>​    </p>
<table>
<thead>
<tr>
<th>.</th>
<th>匹配任意一个字符，除了\n</th>
</tr>
</thead>
<tbody><tr>
<td>[]</td>
<td>匹配[]中列举的类型</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字，即0-9</td>
</tr>
<tr>
<td>\D</td>
<td>匹配非数字</td>
</tr>
<tr>
<td>\s</td>
<td>匹配空白，tab 空格</td>
</tr>
<tr>
<td>\S</td>
<td>匹配非空白</td>
</tr>
<tr>
<td>\w</td>
<td>匹配单词字符，即a-z,A-Z,_,0-9</td>
</tr>
<tr>
<td>\W</td>
<td>匹配非单词字符</td>
</tr>
</tbody></table>
<p>正则表达式的斜杠成双原则  \ \        因为编辑器认为\后的字母应该被转义，但是又找不到应该转义成的字符，我们需要的是一个完整的\d，所以斜杠成双。</p>
<table>
<thead>
<tr>
<th>*</th>
<th>匹配前一个字符0或无数次，即可有可无</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>匹配前一个字符1或无数次，即至少有一次</td>
</tr>
<tr>
<td>？</td>
<td>匹配前一个字符1或0次，即不会多于一次</td>
</tr>
<tr>
<td>{m}</td>
<td>匹配前一个字符m次</td>
</tr>
<tr>
<td>{m,}</td>
<td>匹配前一个字符至少m次</td>
</tr>
<tr>
<td>{m,n}</td>
<td>匹配前一个字符m到n次</td>
</tr>
</tbody></table>
<h4 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h4><p>long类型 仅仅是返回值类型 System.currentTimeMillis(),  1970年到现在的毫秒数</p>
<p>Data类型  日期 桥梁  由于千年虫事件 基本上不使用  被用来进行long类型和Calendar类型的数据转换以及时间的展示</p>
<p>Calendar类型  日历 日期的运算 属于抽象类，使用它的子类（GregorianGalendar）进行实例化，或者使用Calendar中的getInstance()方法  子类gregorianCalendar</p>
<p>从字符串转换为时间类型  DateFormat 抽象类，子类simpleDateFormat</p>
<p>格式化 date–》string</p>
<p>解析 string—》date</p>
<h4 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h4><p>​    Collection 接口</p>
<p>add，remove，size，contains</p>
<p>addAll,  合并不会去重</p>
<p>removeAll, 去重交集</p>
<p>retainAll  得到交集</p>
<p>根据类型的equals和hashcode进行判断</p>
<h3 id="List接口-默认为集合-（有序、重复）"><a href="#List接口-默认为集合-（有序、重复）" class="headerlink" title="List接口 ===默认为集合  （有序、重复）"></a>List接口 ===默认为集合  （有序、重复）</h3><p>List允许出现重复元素，线性方式的有序存储，通过索引来访问集合中的指定元素</p>
<h5 id="如果list是Integer泛型的话，如果使用remove方法，这里必须要理解的是：如果不需要自动装箱就能调用方法的话，就不会进行自动装箱。"><a href="#如果list是Integer泛型的话，如果使用remove方法，这里必须要理解的是：如果不需要自动装箱就能调用方法的话，就不会进行自动装箱。" class="headerlink" title="*如果list是Integer泛型的话，如果使用remove方法，这里必须要理解的是：如果不需要自动装箱就能调用方法的话，就不会进行自动装箱。"></a>*如果list是Integer泛型的话，如果使用remove方法，这里必须要理解的是：如果不需要自动装箱就能调用方法的话，就不会进行自动装箱。</h5><p>ArrayList在操作指定下标的任意元素上面，速度比较快。(查找上和指定下标操作的操作上速度比较快)。</p>
<p>LinkedList底层是双向链表，所以在操作首尾元素的操作上速度比较快。</p>
<p>vector自从ArrayList出现以后，就不再使用了</p>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>相当于把所有的集合元素按照他们指定的顺序排放在一个类似于线性表的集合中。</p>
<p>使用集合对象调用iterator方法，获取iterator对象，如果有泛型，iterator也可以使用相应的泛型。</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>为了将运行时异常转换为编译时异常（深层次）</p>
<p>泛型不存在继承关系</p>
<h3 id="set接口"><a href="#set接口" class="headerlink" title="set接口"></a>set接口</h3><p>set接口中的元素无序，并且存入的元素不重复出现。</p>
<p>HashSet</p>
<p>​    无序且不重复、重写hashcode和equals方法</p>
<p>LinkedHashSet</p>
<p>​        有序</p>
<p>TreeSet(实现了set和sortset)</p>
<p>​     具有自然排序功能的类</p>
<p>​    可以自定义排序</p>
<p>​    不重复，不能放null</p>
<p>​    因为TreeSet这个类需要吧里面的元素进行统一类型来比较，所以会配套使用泛型</p>
<p>​    TreeSet对自定义数据类型进行排序的话，需要两个前提</p>
<p>​                实现comparable接口</p>
<p>​                有具体的排序方法</p>
<h3 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h3><p>在java中有两个常用的接口，分别是Comparator接口和Comparable接口</p>
<p>Comparator接口</p>
<p>​    临时  重写 compare方法 两个参数</p>
<p>​    经常在Arrays.sort以及Collections.sort里面来使用</p>
<p>​    不能在TreeSet中使用</p>
<p>​    使用内名内部类</p>
<p>Comparable接口</p>
<p>​    持久 重写 compareTo方法  一个参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 都返回0的话，就会输出一个元素</span><br><span class="line">&#x2F;&#x2F; 返回正数时，代表该属性值的升序--&gt;本身属性-参数属性</span><br><span class="line">&#x2F;&#x2F; 返回负数时，代表该属性值的降序--&gt;参数属性-本身属性</span><br></pre></td></tr></table></figure>

<h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><p> 等同于set的定义，建唯一不重复。键值对</p>
<p>​    键 无序、无下标、不允许重复</p>
<p>​    值 无序、无下标、允许重复</p>
<p>HashMap 不能保证顺序，键采用自定义类型时，就要重写hashCode和equals方法</p>
<p>LinkedHashMap  多了排序的功能</p>
<p>TreeSet 自然排序且键不重复，可以采用自定义比较。</p>
<p>HashMap与Hashtable的关系    ArrayList和vector的关系</p>
<h3 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h3><p>​    编写错误不属于异常（需要try catch的才是编译型异常）</p>
<p>​    printStackTrace() 打印异常的详细信息。包含了异常的类型，异常的原因，异常出现的位置</p>
<p>​    getMessage() 获取异常的原因</p>
<p>​    toString() 获取异常的类型和异常描述信息</p>
<p>异常处理方式</p>
<p>​    try  catch  finally   不加catch的话会结束程序的执行</p>
<p>​    throw 后面跟异常对象  并且结束当前方法的执行 </p>
<p>​    throw 后面如果接运行时环境，一旦改代码执行，那么程序会停止，如果后面是检查时异常，就会要求你处理异常，程序不会停止。</p>
<p>​    如果throw后面跟的是一个编译时异常，jvm就会要求你必须处理此异常</p>
<p>​    throws 放在方法结构尾部，用来告诉方法的调用者，这个方法有异常。</p>
<p>​    Exception 和 继承Exception类的子类 属于编译期异常（除了RuntimeException 和 它的子类）</p>
<p>​    RuntimeException和继承 了RuntimeException的子类</p>
<p>​    自定义异常就是继承Exception或RuntimeException</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>​    通过字节码对象获取，把类的各个组成部分（属性，构造函数和方法）给获取到</p>
<p>​    能干什么？</p>
<p>​    获取类的相关信息，动态调用方法，动态调用属性</p>
<p>Class类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">getName  forName  newInstance</span><br><span class="line"></span><br><span class="line">   getField(String)  getDeclaredField(String) getFields getDeclaredFields</span><br><span class="line"></span><br><span class="line">getMethod(String name,Class... &lt;?&gt; parameterType)   getDeclaredField getMethods   getDeclaredFields</span><br><span class="line"></span><br><span class="line">getConstructor(Class... &lt;?&gt; parameterType)  getDeclaredField  getConstructors  getDeclaredFields</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Field类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get(Object o); <span class="comment">// 返回一个Object 获取该对象的相对应的属性</span></span><br><span class="line">set(Object o, 值) <span class="comment">// 修改该对象的值</span></span><br><span class="line"><span class="comment">// NoSuchFieldException 获取非公有属性  解决 getDeclaredField</span></span><br><span class="line"><span class="comment">// IllegalAccessException 非法访问  解决  使用之前赋予权限  setAccessible(true)</span></span><br></pre></td></tr></table></figure>

<p>Method类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get(Object,Class...&lt;?&gt; ParameterType ) <span class="comment">// ParameterType 是类型，不是具体的值</span></span><br><span class="line">invoke(Object o , Object... Parameter) <span class="comment">// Parameter为具体的值</span></span><br><span class="line"><span class="comment">// NoSuchFieldException 获取非公有属性  解决 getDeclaredMethod</span></span><br><span class="line"><span class="comment">// IllegalAccessException 非法访问  解决  使用之前赋予权限  setAccessible(true)</span></span><br></pre></td></tr></table></figure>

<p>Constructor类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newInstance <span class="comment">// 创建一个新对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="工厂设计模式"><a href="#工厂设计模式" class="headerlink" title="工厂设计模式"></a>工厂设计模式</h3><p>这个创建模式让我们在创建对象时不会暴露创建逻辑，而是通过使用一个共同的接口来完成对象的创建</p>
<p>简单工厂、工厂方法、抽象工厂</p>
<p>优点：</p>
<p>​    调用者想创建一个对象，只需要知道其名称，</p>
<p>​    拓展性强，想增加产品，只要扩展产品类</p>
<p>​    屏蔽产品的具体实现，无需关心内部实现</p>
<p>​    面向接口编程</p>
<h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><h5 id="File类-（不能读-写文件内容，只能操作文件或文件夹的属性）文件或目录路径的抽象表现形式"><a href="#File类-（不能读-写文件内容，只能操作文件或文件夹的属性）文件或目录路径的抽象表现形式" class="headerlink" title="File类 （不能读/写文件内容，只能操作文件或文件夹的属性）文件或目录路径的抽象表现形式"></a>File类 （不能读/写文件内容，只能操作文件或文件夹的属性）文件或目录路径的抽象表现形式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">exist() &#x2F;&#x2F; 是否存在</span><br><span class="line">createNewFile() &#x2F;&#x2F; 创建新文件  eg\创建文件的目录必须存在</span><br><span class="line">isHidden()&#x2F;&#x2F; 判断文件是否隐藏</span><br><span class="line">isFile()&#x2F;&#x2F; 判断是否为普通的文件</span><br><span class="line">length() &#x2F;&#x2F; 文件的长度</span><br><span class="line">isDirectory()&#x2F;&#x2F;是否为文件夹</span><br><span class="line">mkdir()&#x2F;&#x2F;创建一个文件夹</span><br><span class="line">mkdirs()&#x2F;&#x2F;创建层级文件夹</span><br><span class="line">renameTo(File dest) &#x2F;&#x2F; 更改文件的名字</span><br><span class="line">delete() &#x2F;&#x2F; 删除文件         eg、如果删除文件夹，文件夹下面不能有文件</span><br><span class="line">listFiles() &#x2F;&#x2F; 列出指定路径下的所有文件</span><br><span class="line">getAbsolutePath() &#x2F;&#x2F;获取绝对路径</span><br><span class="line">getCanonicalPath() &#x2F;&#x2F; 获取规范形式 建议使用</span><br><span class="line">getName()  &#x2F;&#x2F; 只有文件名</span><br><span class="line">getPath()  &#x2F;&#x2F; 路径名字</span><br><span class="line">listFile(FileFilter filter)</span><br></pre></td></tr></table></figure>

<h3 id="流对象"><a href="#流对象" class="headerlink" title="流对象"></a>流对象</h3><p>字节流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InputStream  实现了Closeable接口，可以被关闭</span><br><span class="line">    FileInputStream</span><br><span class="line">    FilterInputStream  <span class="comment">// 相当于私人订制</span></span><br><span class="line">    	BufferedInputStream</span><br><span class="line">    	DataInputStream <span class="comment">// 专门处理基本数据类型的流</span></span><br><span class="line">    	PushbakInputStream</span><br><span class="line">    ObjectInputStream</span><br><span class="line">OutputStream  实现了closeable，Flushable接口</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>InputStream</p>
<ul>
<li>available() 返回长度</li>
</ul>
<p>FileOutputStream</p>
<ul>
<li>read()  已经读完的情况下在读是-1  返回的是游标的位置</li>
</ul>
<p>字符流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Reader</span><br><span class="line">    BufferedReader 常用</span><br><span class="line">    InputStreamReader  </span><br><span class="line">    	FileReader</span><br><span class="line">Writer</span><br><span class="line">    BufferedWriter 常用</span><br><span class="line">    OutputStreamWriter</span><br><span class="line">    	FileWriter</span><br></pre></td></tr></table></figure>

<p>BufferedReader</p>
<ul>
<li>Read      文件末尾返回null</li>
</ul>
<p>BufferedWriter</p>
<ul>
<li>write</li>
<li>append</li>
<li>newline   另起一行</li>
</ul>
<p>PrinterWriter</p>
<ul>
<li>PrinterWriter（String str）</li>
</ul>
<h3 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h3><p>ObjectOutputStream和ObjectInputStream</p>
<p>一个类要实现序列化，它本身和它的属性必须都实现序列化。对父类无要求</p>
<p>serialVersionUID 使用来标识类的，来判断是否是同一个类，不写的话会自动计算生成</p>
<p>不想属性进行序列化解决方法</p>
<ul>
<li>加上static（类资源不会进行序列化）</li>
<li>加上transient修饰词(当类实现的是Externalizable接口时，可以通过重写序列化和反序列化的方法指定某些属性进行序列化和反序列化，这时transient关键字失效)</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>一个线程可以创建和撤销另一个线程</p>
<p>线程基本上不拥有系统资源</p>
<p>线程之间交替工作，被称为多线程。</p>
<p>线程的组成</p>
<ul>
<li>cpu时间片</li>
<li>运行数据（栈内存、堆内存）</li>
<li>线程的业务逻辑代码</li>
</ul>
<p>同步（并发）多个线程按照一定的顺序逐个进行执行。</p>
<p>异步（并行）多个线程一起不按顺序的执行。</p>
<h4 id="1、多线程的创建"><a href="#1、多线程的创建" class="headerlink" title="1、多线程的创建"></a>1、多线程的创建</h4><p>Thread类 实现run方法，调用start方法（如果执行run方法，不会开启一个新的线程）</p>
<ul>
<li>多个线程分别完成自己的任务</li>
</ul>
<p>Runnable接口 实现run方法，但是还需要Threand类的start方法</p>
<ul>
<li>多个线程共同完成一个任务</li>
<li>线程池只能放入实现Runable或Callable类线程，不能放入Thread子类</li>
</ul>
<p>指定多线程的名字     setName方法</p>
<h4 id="多线程的状态管理（生命周期）"><a href="#多线程的状态管理（生命周期）" class="headerlink" title="多线程的状态管理（生命周期）"></a>多线程的状态管理（生命周期）</h4><p>New状态：多线程被创建出来，还没有调用start方法之前，属于这种状态。</p>
<p>Ready状态：调用了start方法，此时处于多个线程在争夺cpu使用权。</p>
<p>Runnable状态：当某个多线程抢夺到了cpu的使用权，并且开始运行他的业务逻辑的时候</p>
<p>Block状态：当多线程由于外部原因导致它无法继续执行业务逻辑的时候，</p>
<ul>
<li>a、锁阻塞</li>
<li>b、指定时长的等待</li>
<li>c、不指定时长的等待</li>
</ul>
<p>Terminated状态：当多线程业务逻辑执行完毕，属于这种状态，一旦进入这种状态，线程对象就无法调用方法了。</p>
<h4 id="线程的常用方法"><a href="#线程的常用方法" class="headerlink" title="线程的常用方法"></a>线程的常用方法</h4><ul>
<li><p>静态方法</p>
<ul>
<li>currentThread() 获取当前的线程对象</li>
<li>sleep() 让当前线程休眠（注意 因为是静态方法，所以不是按对象执行，而是看当前执行方法的线程） 如 在 t1 t2 线程，在t2中调用t1.sleep() ，t2休眠而不是t1休眠。</li>
<li>activeCount（） 获取当前线程组的活动线程数量。</li>
<li>yield（） 暂停当前线程的运行，让其进入就绪状态和其他的就绪线程抢夺资源。</li>
</ul>
</li>
<li><p>线程相关信息的方法</p>
<ul>
<li>getName()/setName() 线程的名字</li>
<li>getId 线程的id标识符</li>
<li>getPriority()/setPriority()   线程的优先级</li>
<li>getState(）线程的状态</li>
<li>setDaemon(boolean on)  标记为守护线程或用户线程</li>
</ul>
</li>
<li><p>守护线程</p>
<ul>
<li>守护线程，我们也称为后台线程或者是用户线程。</li>
<li>一旦你设置了某个线程为守护线程的话，那么该线程会等待其他线程都结束，它就会自动结束，所以是守护线程我们一般不会设置其有效时间，会让它一直有效，典型的守护线程就是垃圾回收线程</li>
<li>设置一个线程为守护线程要在start方法调用之前来设置。</li>
</ul>
</li>
<li><p>线程判断的方法</p>
<ul>
<li>isAlive()</li>
<li>isDaemon()</li>
<li>isInterupted()</li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li>join（）等待该线程终止再开始其他线程 放在start之后调用才有效</li>
</ul>
</li>
</ul>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>多个线程同时使用同一个共享资源所导致的。</p>
<p>解决方法 锁（synchronized）</p>
<ul>
<li>对资源进行加锁</li>
</ul>
<p>互斥锁的使用方式</p>
<ul>
<li>隐式锁<ul>
<li>代码块上锁</li>
<li>方法上锁</li>
</ul>
</li>
<li>显式锁<ul>
<li>lock上锁（jdk1.5之后）</li>
</ul>
</li>
</ul>
<p>代码块加锁</p>
<p>​    synchronized关键字可以用于方法的某个区域中，</p>
<p>​    synchronized（同步锁）{</p>
<p>​        需要同步操作的代码</p>
<p>​    }</p>
<p>​    同步锁的解释</p>
<p>​    对象的同步锁只是一个概念，可以想象为在对象上标记了一个锁，同步锁的要求：</p>
<p>​    1、所对象可以是任意类型，我们一般直接使用Object对象</p>
<p>​    2、保证这些线程对象使用的是同一把锁。</p>
<p>​    注意：</p>
<p>​    1、在任意时候，最多允许一个线程拥有同步锁，谁拿到锁就进入代码，其余代码只能在外边等着（Blocked）</p>
<p>​    2、对于非static方法，同步锁就是this。对于static方法，我们使用当前方法所在类的字节码对象。</p>
<p>​    ps：sleep不释放锁资源，wait释放锁资源。</p>
<p>​    可以使用lock接口，ReentrantLock是lock的实现类</p>
<p>​    方法</p>
<p>​        lock()</p>
<p>​        unlock()</p>
<h4 id="多线程唤醒的三种方式"><a href="#多线程唤醒的三种方式" class="headerlink" title="多线程唤醒的三种方式"></a>多线程唤醒的三种方式</h4><p>​    interrupt()    sleep()</p>
<p>​    notify()</p>
<p>​    notifyAll()</p>
<h4 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h4><p>​        让多个线程之间可以进行进行同一件事情，需要线程之间进行协调。</p>
<p>​        wait和notify函数必须在同步代码块后者同步函数中使用。</p>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>使用：</p>
<p>​    1、使用线程池的工具类Executors里面所提供的静态方法newFixedThreadPool（int nThreads）来构建一个指定线程数量的线程池对象。</p>
<p>​    2、创建一个Runnable的子类，然后在run方法中写明你的任务逻辑代码。</p>
<p>​    3、通过创建出来的ExecutorServices对象中的submit方法来执行你创建的Runnable子类。</p>
<p>​    4、如果你不再使用线程池了，可以用shutDown（）关闭它。</p>
<h3 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h3><p>​    1、lambda表达式</p>
<p>​    2、方法引用</p>
<p>​        有现成的方法使用，就是用现成的方法。（相当于对lambda表达式的进一步优化）</p>
<p>​        testInterface2(System.out::println)</p>
<p>​        </p>
<p>​    3、函数式接口</p>
<p>​        就是符合lambda表达式的接口，确保接口中有且只有一个抽象方法</p>
<p>​        在接口上使用@FunctionalInterface注解,如果是函数式接口，则编译通过，否则不通过。</p>
<p>​        可以作为参数和返回类型。</p>
<p>​        四种新常用的函数式接口（1.8）</p>
<p>​            Supplier接口  提供一个数据</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;T&gt;:包含一个无参的方法，用来获取一个泛型参数指定类型的对象数据。</span><br><span class="line">Tget():获得结果，不需要参数，它会按照某种实现逻辑（由 Lambda表达式实现返回一个数据</span><br><span class="line">Supplier&lt;T&gt;接口也被称为生产型接口，如果我们指定了接口的泛型是什么类型，那么接口中的get方法就会</span><br><span class="line">生产什么类型的数据供我们使用</span><br></pre></td></tr></table></figure>

<p>​            Consumer接口    </p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;T&gt;:也被称为消费型接口，该接口正好与 Supplier接口相反，它不是生产一个数据，而是消费一</span><br><span class="line">个数据，其数据类型由泛型决定。</span><br><span class="line">void accept(T t):对给定的参数执行此操作。</span><br><span class="line">default Consumer&lt;T&gt; andthen( Consumer after):返回一个组合的 Consumer,依次执行此操作，然后执行 afterf操作。</span><br></pre></td></tr></table></figure>



<p>​            Predicate接口</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;T&gt;:通常用于判断参数是否满足指定的条件</span><br><span class="line">boolean test(Tt):对给定的参数进行判断(判断逻辑由 Lambda表达式实现)，返回一个布尔值</span><br><span class="line">default Predicates&gt; negate（）:返回一个逻辑的否定，对应逻辑非</span><br><span class="line">default Predicate&lt;T&gt;and( Predicate other):返回一个组合判断，对应短路与</span><br><span class="line">default Predicate&lt;T&gt;or( Predicate other):返回一个组合判断，对应短路或</span><br></pre></td></tr></table></figure>



<p>​            Function接口</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;T,R&gt;:接口通常用于对参数进行处理，转換(处理逻辑由 Lambda表达式实现)，然后返回一个新的值</span><br><span class="line">Apply(Tt):将此函数应用于给定的参数</span><br><span class="line">default&lt;V&gt; Function andthen( Function after):返回一个组合函数，首先将该函数应用于输入，然后将 after</span><br><span class="line">函数应用于结果</span><br></pre></td></tr></table></figure>

<h3 id="stream流"><a href="#stream流" class="headerlink" title="stream流"></a>stream流</h3><p>流可以理解为是一种用来处理数据容器的东西。可以和lambda表达式相结合一起进行操作。</p>
<p>流的生成</p>
<p>​    1、Collection接口下的子类</p>
<p>​        list.stream()    set.stream()</p>
<p>​    2、Map接口下的子类</p>
<p>​        根据需求来进行键、值或者Entry对象的转换为stream流</p>
<p>​        map.keySet().stream()    map.values().stream()    map.entrySet().stream()</p>
<p>​    3、数组</p>
<p>​        直接调用Stream类的静态方法of</p>
<p>​        Stream.of(strArray)</p>
<p>​    4、结束流</p>
<p>​        count    forEach</p>
<p>​    5、Stream转换到Collection</p>
<p>​        R collect(Collector collector)</p>
<p>​        Collectors工具类</p>
<p>​            public static <T> Collector toList() : 把元素收集到list集合中</p>
<p>​            public static <T> Collector toSet() : 把元素收集到set集合中            </p>
<p>​            public static  Collector toMap(Function keyMapper,Function valueMapper) : 把元素收集到map集合中</p>
<hr>
<p>东软</p>
<p>操作数栈的概念</p>
<p>jdbc的连接步骤(引入jar包，mysql connector/J , lombok  @Data,  )</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1、选择数据库的种类  Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</span><br><span class="line">2、创建连接，数据库地址，用户名、地址 Connnetion conn &#x3D; DriverManager.getConnnection(&quot;jdbc:mysql:&#x2F;&#x2F;192.168.80.131:3306&#x2F;db1?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&quot;,&quot;root&quot;,&quot;123456&quot;);</span><br><span class="line">3、选择要操作的数据库</span><br><span class="line">上一步已经写好了</span><br><span class="line">4、写sql语句</span><br><span class="line">con.createStatement(String sql) &#x2F;&#x2F; 少数 无预编译</span><br><span class="line">PrepareStatement pstmt &#x3D; con.prepareStataement(String sql) &#x2F;&#x2F; 多数 有预编译</span><br><span class="line">5、执行sql语句</span><br><span class="line">ResultSet rs &#x3D;  pstmt.executeQuery();</span><br><span class="line">6、处理结果集</span><br><span class="line">while(rs.next())&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>泛型逆向推到必须要写<T></p>
<p>单继承多实现</p>
<p>抽象类中可以有构造方法，接口中不可以有构造方法。</p>
<p>抽象类中可以有抽象方法和非抽象方法，接口中可以有非抽象方法（jdk8及以后）</p>
<p>字符流字节流之间转换： inputStreamReader       bufferedReader</p>
<p>远程调用 一个机器上的controller层调用另一台机器上的service层 通过url调用</p>
<p>跨语言无法传输字节流，可以使用json或xml格式</p>
<p>分布式：将程序分为一个个的模块项目。（简单来说就是合力做一件事）</p>
<p>消息中间件：类似于数组。英文全称“Message Queue”，简称MQ。</p>
<p>事务：事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤            消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。</p>
<p>事务的四大特性：ACID,原子性（Atomicity）,一致性（correspondence），隔离性（Isolation）,持久性（durability）。</p>
<p>​    （1）原子性：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。<br>​      （2）一致性：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。<br>​      （3）隔离性：隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，  必须串行化或序列化请 求，使得在同一时间仅有一个请求用于同一数据。<br>​      （4）持久性：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p>
<p>进程：正在运行的程序</p>
<p>线程：是操作系统能够进行运算调度的最小单位，是进程中的实际运作单位。</p>
<p>javaee是通讯框架</p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>私有化构造方法</p>
<p>​    饥饿式：先构造一个static的对象</p>
<p>​    懒汉式： 先设置一个为null的static的变量，等调用对象的时候再进行生成。  因为是单实例多线程的调用需要加锁。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
