<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="java java构造赋值，先父类后子类，先默认后构造的顺序。 父类与子类： ​         子父类拥有相同的变量，规则：自己有用自己，自己无用父类。      父类实现先于子类实现，显式调用父类构造器或者隐藏调用父类无参构造器 ​    Serializable接口，相当于一个标志，告诉jvm可以将该类的对象进行序列化和反序列化。（可以使用transient修饰那些不需要序列化的属性），最好">
<meta property="og:type" content="article">
<meta property="og:title" content="java学习">
<meta property="og:url" content="http://example.com/2020/12/01/java/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="java java构造赋值，先父类后子类，先默认后构造的顺序。 父类与子类： ​         子父类拥有相同的变量，规则：自己有用自己，自己无用父类。      父类实现先于子类实现，显式调用父类构造器或者隐藏调用父类无参构造器 ​    Serializable接口，相当于一个标志，告诉jvm可以将该类的对象进行序列化和反序列化。（可以使用transient修饰那些不需要序列化的属性），最好">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-12-01T03:26:32.000Z">
<meta property="article:modified_time" content="2021-05-20T08:51:58.452Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2020/12/01/java/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>java学习 | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/01/java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          java学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-01 11:26:32" itemprop="dateCreated datePublished" datetime="2020-12-01T11:26:32+08:00">2020-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-20 16:51:58" itemprop="dateModified" datetime="2021-05-20T16:51:58+08:00">2021-05-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>java</p>
<p>java构造赋值，先父类后子类，先默认后构造的顺序。</p>
<p>父类与子类：</p>
<p>​         子父类拥有相同的变量，规则：自己有用自己，自己无用父类。</p>
<pre><code>     父类实现先于子类实现，显式调用父类构造器或者隐藏调用父类无参构造器</code></pre>
<p>​    Serializable接口，相当于一个标志，告诉jvm可以将该类的对象进行序列化和反序列化。（可以使用transient修饰那些不需要序列化的属性），最好自己写一个serialVersionUID(static final long)，不会序列化static关键字修饰的属性。如果父类没有实现Serializable接口，那么必须有无参构造函数。</p>
<p>​    Externalizable接口，需要重写writeExternal和readExternal方法,效率比Serializable高，可以决定哪些属性需要序列化（即使transient修饰的），但是面对大量对象，或者重复对象，则效率低。</p>
<p>​    package打包后的类可以不在同一个文件夹中，但是所在文件夹的名字必须与包名一致。</p>
<p>​    import关键字，使用*号时，只会导入该包内的类，并不会导入包。</p>
<p>​    </p>
<p>抽象类：</p>
<p>​    防止创建没有对象性质的对象（例如：动物），只应该有方法声明，不应该有方法主题。</p>
<p>​    抽象类也是具有构造函数的，所有子类实现都必须先执行抽象类的构造函数。</p>
<p>​    抽象类中可以存在0到多个抽象方法，也可存在0到多个非抽象方法</p>
<p>接口：</p>
<p>​    接口是一种特殊的抽象类，也是引用数据类型（数组，类，接口）,包含抽象方法( public abstract)，（静态方法和默认方法(default不可省)）jdk8以后，成员属性都是常量（public static final）</p>
<p>​    默认方法，子类不需要重写。</p>
<p>​    实现接口是为了实现某个功能，是为了进行拓展。</p>
<p>类中代码会在属性初始化之后，无参构造函数之前</p>
<p>static</p>
<p>​    static 关键字修饰的 可以继承 但是不可以重写</p>
<p>final    </p>
<p>​    final 修饰成员变量必须赋值（直接赋值，代码块赋值，构造方法赋值），修饰局部变量可以声明和赋值分开。</p>
<p>​    final修饰的形参也是不能改变的</p>
<p>​    final 修饰引用类型，可以更改引用对象。</p>
<p>​    static final 修饰的就是一个常量  （直接赋值，静态代码块赋值）</p>
<p>​    final 修饰的方法不允许被重写</p>
<p>​    final 修饰的类不能被继承</p>
<p>多态</p>
<p>​    成员属性看左边，成员方法看右边（方法里面用右边变量）</p>
<p>Hashcode编码</p>
<p>​    用的Object.hash(Object… values)   底层 Arrays.hashCode(values)</p>
<p>实现clone方法</p>
<p>​    实现Cloneable接口,才能重写Object类的clone方法</p>
<p>javaBean规范</p>
<p>​    必须要有包</p>
<p>​    属性私有化</p>
<p>​    get、set方法</p>
<p>​    实现接口序列化  Serializable</p>
<p>​    public修饰类</p>
<p>​    增加无参构造函数</p>
<p>String类</p>
<p>​    底层char数组，String对象永远不变</p>
<p>​    字符串池的存在，所以字符串字面量是共享的</p>
<p>​    底层是char数组，所以可以进行char数组和字符串的互转</p>
<p>​    intern方法: （手动优化）如果字符串池中有则返回字符串池中得，否则向池中添加再返回</p>
<p>​    match方法：正则表达式</p>
<p>StringBuilder（异步，不安全）</p>
<p>​    append: 添加</p>
<p>​    insert: 插入位置的前面</p>
<p>​    delete: 删除包前不包后</p>
<p>正则表达式的作用</p>
<p>​    判断句子是否符合你的规则   match</p>
<p>​    按照你的规则进行文本切割   split</p>
<p>​    在文本中替换你想要得格式    replaceAll</p>
<p>​    </p>
<table>
<thead>
<tr>
<th>.</th>
<th>匹配任意一个字符，除了\n</th>
</tr>
</thead>
<tbody><tr>
<td>[]</td>
<td>匹配[]中列举的类型</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字，即0-9</td>
</tr>
<tr>
<td>\D</td>
<td>匹配非数字</td>
</tr>
<tr>
<td>\s</td>
<td>匹配空白，tab 空格</td>
</tr>
<tr>
<td>\S</td>
<td>匹配非空白</td>
</tr>
<tr>
<td>\w</td>
<td>匹配单词字符，即a-z,A-Z,_,0-9</td>
</tr>
<tr>
<td>\W</td>
<td>匹配非单词字符</td>
</tr>
</tbody></table>
<p>正则表达式的斜杠成双原则  \ \        因为编辑器认为\后的字母应该被转义，但是又找不到应该转义成的字符，我们需要的是一个完整的\d，所以斜杠成双。</p>
<table>
<thead>
<tr>
<th>*</th>
<th>匹配前一个字符0或无数次，即可有可无</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>匹配前一个字符1或无数次，即至少有一次</td>
</tr>
<tr>
<td>？</td>
<td>匹配前一个字符1或0次，即不会多于一次</td>
</tr>
<tr>
<td>{m}</td>
<td>匹配前一个字符m次</td>
</tr>
<tr>
<td>{m,}</td>
<td>匹配前一个字符至少m次</td>
</tr>
<tr>
<td>{m,n}</td>
<td>匹配前一个字符m到n次</td>
</tr>
</tbody></table>
<h4 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h4><p>long类型 仅仅是返回值类型 System.currentTimeMillis(),  1970年到现在的毫秒数</p>
<p>Data类型  日期 桥梁  由于千年虫事件 基本上不使用  被用来进行long类型和Calendar类型的数据转换以及时间的展示</p>
<p>Calendar类型  日历 日期的运算 属于抽象类，使用它的子类（GregorianGalendar）进行实例化，或者使用Calendar中的getInstance()方法  子类gregorianCalendar</p>
<p>从字符串转换为时间类型  DateFormat 抽象类，子类simpleDateFormat</p>
<p>格式化 date–》string</p>
<p>解析 string—》date</p>
<h4 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h4><p>​    Collection 接口</p>
<p>add，remove，size，contains</p>
<p>addAll,  合并不会去重</p>
<p>removeAll, 去重交集</p>
<p>retainAll  得到交集</p>
<p>根据类型的equals和hashcode进行判断</p>
<h3 id="List接口-默认为集合-（有序、重复）"><a href="#List接口-默认为集合-（有序、重复）" class="headerlink" title="List接口 ===默认为集合  （有序、重复）"></a>List接口 ===默认为集合  （有序、重复）</h3><p>List允许出现重复元素，线性方式的有序存储，通过索引来访问集合中的指定元素</p>
<h5 id="如果list是Integer泛型的话，如果使用remove方法，这里必须要理解的是：如果不需要自动装箱就能调用方法的话，就不会进行自动装箱。"><a href="#如果list是Integer泛型的话，如果使用remove方法，这里必须要理解的是：如果不需要自动装箱就能调用方法的话，就不会进行自动装箱。" class="headerlink" title="*如果list是Integer泛型的话，如果使用remove方法，这里必须要理解的是：如果不需要自动装箱就能调用方法的话，就不会进行自动装箱。"></a>*如果list是Integer泛型的话，如果使用remove方法，这里必须要理解的是：如果不需要自动装箱就能调用方法的话，就不会进行自动装箱。</h5><p>ArrayList在操作指定下标的任意元素上面，速度比较快。(查找上和指定下标操作的操作上速度比较快)。</p>
<p>LinkedList底层是双向链表，所以在操作首尾元素的操作上速度比较快。</p>
<p>vector自从ArrayList出现以后，就不再使用了</p>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>相当于把所有的集合元素按照他们指定的顺序排放在一个类似于线性表的集合中。</p>
<p>使用集合对象调用iterator方法，获取iterator对象，如果有泛型，iterator也可以使用相应的泛型。</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>为了将运行时异常转换为编译时异常（深层次）</p>
<p>泛型不存在继承关系</p>
<h3 id="set接口"><a href="#set接口" class="headerlink" title="set接口"></a>set接口</h3><p>set接口中的元素无序，并且存入的元素不重复出现。</p>
<p>HashSet</p>
<p>​    无序且不重复、重写hashcode和equals方法</p>
<p>LinkedHashSet</p>
<p>​        有序</p>
<p>TreeSet(实现了set和sortset)</p>
<p>​     具有自然排序功能的类</p>
<p>​    可以自定义排序</p>
<p>​    不重复，不能放null</p>
<p>​    因为TreeSet这个类需要吧里面的元素进行统一类型来比较，所以会配套使用泛型</p>
<p>​    TreeSet对自定义数据类型进行排序的话，需要两个前提</p>
<p>​                实现comparable接口</p>
<p>​                有具体的排序方法</p>
<h3 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h3><p>在java中有两个常用的接口，分别是Comparator接口和Comparable接口</p>
<p>Comparator接口</p>
<p>​    临时  重写 compare方法 两个参数</p>
<p>​    经常在Arrays.sort以及Collections.sort里面来使用</p>
<p>​    不能在TreeSet中使用</p>
<p>​    使用内名内部类</p>
<p>Comparable接口</p>
<p>​    持久 重写 compareTo方法  一个参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 都返回0的话，就会输出一个元素</span><br><span class="line">&#x2F;&#x2F; 返回正数时，代表该属性值的升序--&gt;本身属性-参数属性</span><br><span class="line">&#x2F;&#x2F; 返回负数时，代表该属性值的降序--&gt;参数属性-本身属性</span><br></pre></td></tr></table></figure>

<h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><p> 等同于set的定义，建唯一不重复。键值对</p>
<p>​    键 无序、无下标、不允许重复</p>
<p>​    值 无序、无下标、允许重复</p>
<p>HashMap 不能保证顺序，键采用自定义类型时，就要重写hashCode和equals方法</p>
<p>LinkedHashMap  多了排序的功能</p>
<p>TreeSet 自然排序且键不重复，可以采用自定义比较。</p>
<p>HashMap与Hashtable的关系    ArrayList和vector的关系</p>
<h3 id="Throwable"><a href="#Throwable" class="headerlink" title="Throwable"></a>Throwable</h3><p>​    编写错误不属于异常（需要try catch的才是编译型异常）</p>
<p>​    printStackTrace() 打印异常的详细信息。包含了异常的类型，异常的原因，异常出现的位置</p>
<p>​    getMessage() 获取异常的原因</p>
<p>​    toString() 获取异常的类型和异常描述信息</p>
<p>异常处理方式</p>
<p>​    try  catch  finally   不加catch的话会结束程序的执行</p>
<p>​    throw 后面跟异常对象  并且结束当前方法的执行 </p>
<p>​    throw 后面如果接运行时环境，一旦改代码执行，那么程序会停止，如果后面是检查时异常，就会要求你处理异常，程序不会停止。</p>
<p>​    如果throw后面跟的是一个编译时异常，jvm就会要求你必须处理此异常</p>
<p>​    throws 放在方法结构尾部，用来告诉方法的调用者，这个方法有异常。</p>
<p>​    Exception 和 继承Exception类的子类 属于编译期异常（除了RuntimeException 和 它的子类）</p>
<p>​    RuntimeException和继承 了RuntimeException的子类</p>
<p>​    自定义异常就是继承Exception或RuntimeException</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>​    通过字节码对象获取，把类的各个组成部分（属性，构造函数和方法）给获取到</p>
<p>​    能干什么？</p>
<p>​    获取类的相关信息，动态调用方法，动态调用属性</p>
<p>Class类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">getName  forName  newInstance</span><br><span class="line"></span><br><span class="line">   getField(String)  getDeclaredField(String) getFields getDeclaredFields</span><br><span class="line"></span><br><span class="line">getMethod(String name,Class... &lt;?&gt; parameterType)   getDeclaredField getMethods   getDeclaredFields</span><br><span class="line"></span><br><span class="line">getConstructor(Class... &lt;?&gt; parameterType)  getDeclaredField  getConstructors  getDeclaredFields</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Field类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get(Object o); <span class="comment">// 返回一个Object 获取该对象的相对应的属性</span></span><br><span class="line">set(Object o, 值) <span class="comment">// 修改该对象的值</span></span><br><span class="line"><span class="comment">// NoSuchFieldException 获取非公有属性  解决 getDeclaredField</span></span><br><span class="line"><span class="comment">// IllegalAccessException 非法访问  解决  使用之前赋予权限  setAccessible(true)</span></span><br></pre></td></tr></table></figure>

<p>Method类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">get(Object,Class...&lt;?&gt; ParameterType ) <span class="comment">// ParameterType 是类型，不是具体的值</span></span><br><span class="line">invoke(Object o , Object... Parameter) <span class="comment">// Parameter为具体的值</span></span><br><span class="line"><span class="comment">// NoSuchFieldException 获取非公有属性  解决 getDeclaredMethod</span></span><br><span class="line"><span class="comment">// IllegalAccessException 非法访问  解决  使用之前赋予权限  setAccessible(true)</span></span><br></pre></td></tr></table></figure>

<p>Constructor类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">newInstance <span class="comment">// 创建一个新对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="工厂设计模式"><a href="#工厂设计模式" class="headerlink" title="工厂设计模式"></a>工厂设计模式</h3><p>这个创建模式让我们在创建对象时不会暴露创建逻辑，而是通过使用一个共同的接口来完成对象的创建</p>
<p>简单工厂、工厂方法、抽象工厂</p>
<p>优点：</p>
<p>​    调用者想创建一个对象，只需要知道其名称，</p>
<p>​    拓展性强，想增加产品，只要扩展产品类</p>
<p>​    屏蔽产品的具体实现，无需关心内部实现</p>
<p>​    面向接口编程</p>
<h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><h5 id="File类-（不能读-写文件内容，只能操作文件或文件夹的属性）文件或目录路径的抽象表现形式"><a href="#File类-（不能读-写文件内容，只能操作文件或文件夹的属性）文件或目录路径的抽象表现形式" class="headerlink" title="File类 （不能读/写文件内容，只能操作文件或文件夹的属性）文件或目录路径的抽象表现形式"></a>File类 （不能读/写文件内容，只能操作文件或文件夹的属性）文件或目录路径的抽象表现形式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">exist() &#x2F;&#x2F; 是否存在</span><br><span class="line">createNewFile() &#x2F;&#x2F; 创建新文件  eg\创建文件的目录必须存在</span><br><span class="line">isHidden()&#x2F;&#x2F; 判断文件是否隐藏</span><br><span class="line">isFile()&#x2F;&#x2F; 判断是否为普通的文件</span><br><span class="line">length() &#x2F;&#x2F; 文件的长度</span><br><span class="line">isDirectory()&#x2F;&#x2F;是否为文件夹</span><br><span class="line">mkdir()&#x2F;&#x2F;创建一个文件夹</span><br><span class="line">mkdirs()&#x2F;&#x2F;创建层级文件夹</span><br><span class="line">renameTo(File dest) &#x2F;&#x2F; 更改文件的名字</span><br><span class="line">delete() &#x2F;&#x2F; 删除文件         eg、如果删除文件夹，文件夹下面不能有文件</span><br><span class="line">listFiles() &#x2F;&#x2F; 列出指定路径下的所有文件</span><br><span class="line">getAbsolutePath() &#x2F;&#x2F;获取绝对路径</span><br><span class="line">getCanonicalPath() &#x2F;&#x2F; 获取规范形式 建议使用</span><br><span class="line">getName()  &#x2F;&#x2F; 只有文件名</span><br><span class="line">getPath()  &#x2F;&#x2F; 路径名字</span><br><span class="line">listFile(FileFilter filter)</span><br></pre></td></tr></table></figure>

<h3 id="流对象"><a href="#流对象" class="headerlink" title="流对象"></a>流对象</h3><p>字节流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">InputStream  实现了Closeable接口，可以被关闭</span><br><span class="line">    FileInputStream</span><br><span class="line">    FilterInputStream  <span class="comment">// 相当于私人订制</span></span><br><span class="line">    	BufferedInputStream</span><br><span class="line">    	DataInputStream <span class="comment">// 专门处理基本数据类型的流</span></span><br><span class="line">    	PushbakInputStream</span><br><span class="line">    ObjectInputStream</span><br><span class="line">OutputStream  实现了closeable，Flushable接口</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>InputStream</p>
<ul>
<li>available() 返回长度</li>
</ul>
<p>FileOutputStream</p>
<ul>
<li>read()  已经读完的情况下在读是-1  返回的是游标的位置</li>
</ul>
<p>字符流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Reader</span><br><span class="line">    BufferedReader 常用</span><br><span class="line">    InputStreamReader  </span><br><span class="line">    	FileReader</span><br><span class="line">Writer</span><br><span class="line">    BufferedWriter 常用</span><br><span class="line">    OutputStreamWriter</span><br><span class="line">    	FileWriter</span><br></pre></td></tr></table></figure>

<p>BufferedReader</p>
<ul>
<li>Read      文件末尾返回null</li>
</ul>
<p>BufferedWriter</p>
<ul>
<li>write</li>
<li>append</li>
<li>newline   另起一行</li>
</ul>
<p>PrinterWriter</p>
<ul>
<li>PrinterWriter（String str）</li>
</ul>
<h3 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h3><p>ObjectOutputStream和ObjectInputStream</p>
<p>一个类要实现序列化，它本身和它的属性必须都实现序列化。对父类无要求</p>
<p>serialVersionUID 使用来标识类的，来判断是否是同一个类，不写的话会自动计算生成</p>
<p>不想属性进行序列化解决方法</p>
<ul>
<li>加上static（类资源不会进行序列化）</li>
<li>加上transient修饰词(当类实现的是Externalizable接口时，可以通过重写序列化和反序列化的方法指定某些属性进行序列化和反序列化，这时transient关键字失效)</li>
</ul>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>一个线程可以创建和撤销另一个线程</p>
<p>线程基本上不拥有系统资源</p>
<p>线程之间交替工作，被称为多线程。</p>
<p>线程的组成</p>
<ul>
<li>cpu时间片</li>
<li>运行数据（栈内存、堆内存）</li>
<li>线程的业务逻辑代码</li>
</ul>
<p>同步（并发）多个线程按照一定的顺序逐个进行执行。</p>
<p>异步（并行）多个线程一起不按顺序的执行。</p>
<h4 id="1、多线程的创建"><a href="#1、多线程的创建" class="headerlink" title="1、多线程的创建"></a>1、多线程的创建</h4><p>Thread类 实现run方法，调用start方法（如果执行run方法，不会开启一个新的线程）</p>
<ul>
<li>多个线程分别完成自己的任务</li>
</ul>
<p>Runnable接口 实现run方法，但是还需要Threand类的start方法</p>
<ul>
<li>多个线程共同完成一个任务</li>
<li>线程池只能放入实现Runable或Callable类线程，不能放入Thread子类</li>
</ul>
<p>指定多线程的名字     setName方法</p>
<h4 id="多线程的状态管理（生命周期）"><a href="#多线程的状态管理（生命周期）" class="headerlink" title="多线程的状态管理（生命周期）"></a>多线程的状态管理（生命周期）</h4><p>New状态：多线程被创建出来，还没有调用start方法之前，属于这种状态。</p>
<p>Ready状态：调用了start方法，此时处于多个线程在争夺cpu使用权。</p>
<p>Runnable状态：当某个多线程抢夺到了cpu的使用权，并且开始运行他的业务逻辑的时候</p>
<p>Block状态：当多线程由于外部原因导致它无法继续执行业务逻辑的时候，</p>
<ul>
<li>a、锁阻塞</li>
<li>b、指定时长的等待</li>
<li>c、不指定时长的等待</li>
</ul>
<p>Terminated状态：当多线程业务逻辑执行完毕，属于这种状态，一旦进入这种状态，线程对象就无法调用方法了。</p>
<h4 id="线程的常用方法"><a href="#线程的常用方法" class="headerlink" title="线程的常用方法"></a>线程的常用方法</h4><ul>
<li><p>静态方法</p>
<ul>
<li>currentThread() 获取当前的线程对象</li>
<li>sleep() 让当前线程休眠（注意 因为是静态方法，所以不是按对象执行，而是看当前执行方法的线程） 如 在 t1 t2 线程，在t2中调用t1.sleep() ，t2休眠而不是t1休眠。</li>
<li>activeCount（） 获取当前线程组的活动线程数量。</li>
<li>yield（） 暂停当前线程的运行，让其进入就绪状态和其他的就绪线程抢夺资源。</li>
</ul>
</li>
<li><p>线程相关信息的方法</p>
<ul>
<li>getName()/setName() 线程的名字</li>
<li>getId 线程的id标识符</li>
<li>getPriority()/setPriority()   线程的优先级</li>
<li>getState(）线程的状态</li>
<li>setDaemon(boolean on)  标记为守护线程或用户线程</li>
</ul>
</li>
<li><p>守护线程</p>
<ul>
<li>守护线程，我们也称为后台线程或者是用户线程。</li>
<li>一旦你设置了某个线程为守护线程的话，那么该线程会等待其他线程都结束，它就会自动结束，所以是守护线程我们一般不会设置其有效时间，会让它一直有效，典型的守护线程就是垃圾回收线程</li>
<li>设置一个线程为守护线程要在start方法调用之前来设置。</li>
</ul>
</li>
<li><p>线程判断的方法</p>
<ul>
<li>isAlive()</li>
<li>isDaemon()</li>
<li>isInterupted()</li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li>join（）等待该线程终止再开始其他线程 放在start之后调用才有效</li>
</ul>
</li>
</ul>
<h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>多个线程同时使用同一个共享资源所导致的。</p>
<p>解决方法 锁（synchronized）</p>
<ul>
<li>对资源进行加锁</li>
</ul>
<p>互斥锁的使用方式</p>
<ul>
<li>隐式锁<ul>
<li>代码块上锁</li>
<li>方法上锁</li>
</ul>
</li>
<li>显式锁<ul>
<li>lock上锁（jdk1.5之后）</li>
</ul>
</li>
</ul>
<p>代码块加锁</p>
<p>​    synchronized关键字可以用于方法的某个区域中，</p>
<p>​    synchronized（同步锁）{</p>
<p>​        需要同步操作的代码</p>
<p>​    }</p>
<p>​    同步锁的解释</p>
<p>​    对象的同步锁只是一个概念，可以想象为在对象上标记了一个锁，同步锁的要求：</p>
<p>​    1、所对象可以是任意类型，我们一般直接使用Object对象</p>
<p>​    2、保证这些线程对象使用的是同一把锁。</p>
<p>​    注意：</p>
<p>​    1、在任意时候，最多允许一个线程拥有同步锁，谁拿到锁就进入代码，其余代码只能在外边等着（Blocked）</p>
<p>​    2、对于非static方法，同步锁就是this。对于static方法，我们使用当前方法所在类的字节码对象。</p>
<p>​    ps：sleep不释放锁资源，wait释放锁资源。</p>
<p>​    可以使用lock接口，ReentrantLock是lock的实现类</p>
<p>​    方法</p>
<p>​        lock()</p>
<p>​        unlock()</p>
<h4 id="多线程唤醒的三种方式"><a href="#多线程唤醒的三种方式" class="headerlink" title="多线程唤醒的三种方式"></a>多线程唤醒的三种方式</h4><p>​    interrupt()    sleep()</p>
<p>​    notify()</p>
<p>​    notifyAll()</p>
<h4 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h4><p>​        让多个线程之间可以进行进行同一件事情，需要线程之间进行协调。</p>
<p>​        wait和notify函数必须在同步代码块后者同步函数中使用。</p>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>使用：</p>
<p>​    1、使用线程池的工具类Executors里面所提供的静态方法newFixedThreadPool（int nThreads）来构建一个指定线程数量的线程池对象。</p>
<p>​    2、创建一个Runnable的子类，然后在run方法中写明你的任务逻辑代码。</p>
<p>​    3、通过创建出来的ExecutorServices对象中的submit方法来执行你创建的Runnable子类。</p>
<p>​    4、如果你不再使用线程池了，可以用shutDown（）关闭它。</p>
<h3 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h3><p>​    1、lambda表达式</p>
<p>​    2、方法引用</p>
<p>​        有现成的方法使用，就是用现成的方法。（相当于对lambda表达式的进一步优化）</p>
<p>​        testInterface2(System.out::println)</p>
<p>​        </p>
<p>​    3、函数式接口</p>
<p>​        就是符合lambda表达式的接口，确保接口中有且只有一个抽象方法</p>
<p>​        在接口上使用@FunctionalInterface注解,如果是函数式接口，则编译通过，否则不通过。</p>
<p>​        可以作为参数和返回类型。</p>
<p>​        四种新常用的函数式接口（1.8）</p>
<p>​            Supplier接口  提供一个数据</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;T&gt;:包含一个无参的方法，用来获取一个泛型参数指定类型的对象数据。</span><br><span class="line">Tget():获得结果，不需要参数，它会按照某种实现逻辑（由 Lambda表达式实现返回一个数据</span><br><span class="line">Supplier&lt;T&gt;接口也被称为生产型接口，如果我们指定了接口的泛型是什么类型，那么接口中的get方法就会</span><br><span class="line">生产什么类型的数据供我们使用</span><br></pre></td></tr></table></figure>

<p>​            Consumer接口    </p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;T&gt;:也被称为消费型接口，该接口正好与 Supplier接口相反，它不是生产一个数据，而是消费一</span><br><span class="line">个数据，其数据类型由泛型决定。</span><br><span class="line">void accept(T t):对给定的参数执行此操作。</span><br><span class="line">default Consumer&lt;T&gt; andthen( Consumer after):返回一个组合的 Consumer,依次执行此操作，然后执行 afterf操作。</span><br></pre></td></tr></table></figure>



<p>​            Predicate接口</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;T&gt;:通常用于判断参数是否满足指定的条件</span><br><span class="line">boolean test(Tt):对给定的参数进行判断(判断逻辑由 Lambda表达式实现)，返回一个布尔值</span><br><span class="line">default Predicates&gt; negate（）:返回一个逻辑的否定，对应逻辑非</span><br><span class="line">default Predicate&lt;T&gt;and( Predicate other):返回一个组合判断，对应短路与</span><br><span class="line">default Predicate&lt;T&gt;or( Predicate other):返回一个组合判断，对应短路或</span><br></pre></td></tr></table></figure>



<p>​            Function接口</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;T,R&gt;:接口通常用于对参数进行处理，转換(处理逻辑由 Lambda表达式实现)，然后返回一个新的值</span><br><span class="line">Apply(Tt):将此函数应用于给定的参数</span><br><span class="line">default&lt;V&gt; Function andthen( Function after):返回一个组合函数，首先将该函数应用于输入，然后将 after</span><br><span class="line">函数应用于结果</span><br></pre></td></tr></table></figure>

<h3 id="stream流"><a href="#stream流" class="headerlink" title="stream流"></a>stream流</h3><p>流可以理解为是一种用来处理数据容器的东西。可以和lambda表达式相结合一起进行操作。</p>
<p>流的生成</p>
<p>​    1、Collection接口下的子类</p>
<p>​        list.stream()    set.stream()</p>
<p>​    2、Map接口下的子类</p>
<p>​        根据需求来进行键、值或者Entry对象的转换为stream流</p>
<p>​        map.keySet().stream()    map.values().stream()    map.entrySet().stream()</p>
<p>​    3、数组</p>
<p>​        直接调用Stream类的静态方法of</p>
<p>​        Stream.of(strArray)</p>
<p>​    4、结束流</p>
<p>​        count    forEach</p>
<p>​    5、Stream转换到Collection</p>
<p>​        R collect(Collector collector)</p>
<p>​        Collectors工具类</p>
<p>​            public static <T> Collector toList() : 把元素收集到list集合中</p>
<p>​            public static <T> Collector toSet() : 把元素收集到set集合中            </p>
<p>​            public static  Collector toMap(Function keyMapper,Function valueMapper) : 把元素收集到map集合中</p>
<hr>
<p>东软</p>
<p>操作数栈的概念</p>
<p>jdbc的连接步骤(引入jar包，mysql connector/J , lombok  @Data,  )</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1、选择数据库的种类  Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</span><br><span class="line">2、创建连接，数据库地址，用户名、地址 Connnetion conn &#x3D; DriverManager.getConnnection(&quot;jdbc:mysql:&#x2F;&#x2F;192.168.80.131:3306&#x2F;db1?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&quot;,&quot;root&quot;,&quot;123456&quot;);</span><br><span class="line">3、选择要操作的数据库</span><br><span class="line">上一步已经写好了</span><br><span class="line">4、写sql语句</span><br><span class="line">con.createStatement(String sql) &#x2F;&#x2F; 少数 无预编译</span><br><span class="line">PrepareStatement pstmt &#x3D; con.prepareStataement(String sql) &#x2F;&#x2F; 多数 有预编译</span><br><span class="line">5、执行sql语句</span><br><span class="line">ResultSet rs &#x3D;  pstmt.executeQuery();</span><br><span class="line">6、处理结果集</span><br><span class="line">while(rs.next())&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>泛型逆向推到必须要写<T></p>
<p>单继承多实现</p>
<p>抽象类中可以有构造方法，接口中不可以有构造方法。</p>
<p>抽象类中可以有抽象方法和非抽象方法，接口中可以有非抽象方法（jdk8及以后）</p>
<p>字符流字节流之间转换： inputStreamReader       bufferedReader</p>
<p>远程调用 一个机器上的controller层调用另一台机器上的service层 通过url调用</p>
<p>跨语言无法传输字节流，可以使用json或xml格式</p>
<p>分布式：将程序分为一个个的模块项目。（简单来说就是合力做一件事）</p>
<p>消息中间件：类似于数组。英文全称“Message Queue”，简称MQ。</p>
<p>事务：事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤            消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。</p>
<p>事务的四大特性：ACID,原子性（Atomicity）,一致性（correspondence），隔离性（Isolation）,持久性（durability）。</p>
<p>​    （1）原子性：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。<br>​      （2）一致性：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。<br>​      （3）隔离性：隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，  必须串行化或序列化请 求，使得在同一时间仅有一个请求用于同一数据。<br>​      （4）持久性：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p>
<p>进程：正在运行的程序</p>
<p>线程：是操作系统能够进行运算调度的最小单位，是进程中的实际运作单位。</p>
<p>javaee是通讯框架</p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>私有化构造方法</p>
<p>​    饥饿式：先构造一个static的对象</p>
<p>​    懒汉式： 先设置一个为null的static的变量，等调用对象的时候再进行生成。  因为是单实例多线程的调用需要加锁。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/12/01/sy%E7%BB%84%E4%BB%B6/" rel="prev" title="sy组件">
      <i class="fa fa-chevron-left"></i> sy组件
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/12/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E9%9F%A9%E5%BF%97%E5%B9%B3%EF%BC%89/" rel="next" title="数据结构与算法（韩志平）">
      数据结构与算法（韩志平） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">时间类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">集合类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List%E6%8E%A5%E5%8F%A3-%E9%BB%98%E8%AE%A4%E4%B8%BA%E9%9B%86%E5%90%88-%EF%BC%88%E6%9C%89%E5%BA%8F%E3%80%81%E9%87%8D%E5%A4%8D%EF%BC%89"><span class="nav-number"></span> <span class="nav-text">List接口 &#x3D;&#x3D;&#x3D;默认为集合  （有序、重复）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E6%9E%9Clist%E6%98%AFInteger%E6%B3%9B%E5%9E%8B%E7%9A%84%E8%AF%9D%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%BD%BF%E7%94%A8remove%E6%96%B9%E6%B3%95%EF%BC%8C%E8%BF%99%E9%87%8C%E5%BF%85%E9%A1%BB%E8%A6%81%E7%90%86%E8%A7%A3%E7%9A%84%E6%98%AF%EF%BC%9A%E5%A6%82%E6%9E%9C%E4%B8%8D%E9%9C%80%E8%A6%81%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E5%B0%B1%E8%83%BD%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E7%9A%84%E8%AF%9D%EF%BC%8C%E5%B0%B1%E4%B8%8D%E4%BC%9A%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E3%80%82"><span class="nav-number">0.1.</span> <span class="nav-text">*如果list是Integer泛型的话，如果使用remove方法，这里必须要理解的是：如果不需要自动装箱就能调用方法的话，就不会进行自动装箱。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">1.</span> <span class="nav-text">迭代器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-number"></span> <span class="nav-text">泛型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set%E6%8E%A5%E5%8F%A3"><span class="nav-number"></span> <span class="nav-text">set接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E5%99%A8"><span class="nav-number"></span> <span class="nav-text">比较器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map%E6%8E%A5%E5%8F%A3"><span class="nav-number"></span> <span class="nav-text">Map接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Throwable"><span class="nav-number"></span> <span class="nav-text">Throwable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84"><span class="nav-number"></span> <span class="nav-text">反射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number"></span> <span class="nav-text">工厂设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E6%B5%81"><span class="nav-number"></span> <span class="nav-text">IO流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#File%E7%B1%BB-%EF%BC%88%E4%B8%8D%E8%83%BD%E8%AF%BB-%E5%86%99%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%EF%BC%8C%E5%8F%AA%E8%83%BD%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E6%88%96%E6%96%87%E4%BB%B6%E5%A4%B9%E7%9A%84%E5%B1%9E%E6%80%A7%EF%BC%89%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95%E8%B7%AF%E5%BE%84%E7%9A%84%E6%8A%BD%E8%B1%A1%E8%A1%A8%E7%8E%B0%E5%BD%A2%E5%BC%8F"><span class="nav-number">0.1.</span> <span class="nav-text">File类 （不能读&#x2F;写文件内容，只能操作文件或文件夹的属性）文件或目录路径的抽象表现形式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E5%AF%B9%E8%B1%A1"><span class="nav-number"></span> <span class="nav-text">流对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number"></span> <span class="nav-text">序列化和反序列化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number"></span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">1.</span> <span class="nav-text">1、多线程的创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%EF%BC%88%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">多线程的状态管理（生命周期）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">线程的常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">4.</span> <span class="nav-text">线程安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%94%A4%E9%86%92%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">5.</span> <span class="nav-text">多线程唤醒的三种方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-number">6.</span> <span class="nav-text">线程通信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">7.</span> <span class="nav-text">线程池</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E7%89%B9%E6%80%A7"><span class="nav-number"></span> <span class="nav-text">新特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#stream%E6%B5%81"><span class="nav-number"></span> <span class="nav-text">stream流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number"></span> <span class="nav-text">单例模式</span></a></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
